To check whether there are any races, the dynamic programming model currently works with a graph composed of configurations that look like this: ((e1, e2, ..., en), (v1, v2, ..., vm)) where n is the number of threads, m is the number of variables, ei is an event index for thread i and vj is the value for variable j. Then the dynamic programming algorithm starts with the ((0, 0, ..., 0), (0, 0, ..., 0)) state and recursively expands it into all the reachable states.

This is reasonably good, but it's not necessarily better than the SMT model. Indeed, in many cases it is somehow worse.

First, let us notice that, for two threads, if t1 accesses variable v1 with i1 as the event index and t2 accesses v2 at with i1 as the index, then the algorithm has at least one state for the (i1, i2) index pair. However, this pair does not provide anything useful to the analysis. One option would be that we analyse the t1 and t2 threads separately at these indexes, but that gets complicated quickly.

A simple way to optimize this is to run threads in jumps, stopping only at lock acquire and release time. I.e. instead of having simple read/write/whatever instructions we have complex instructions made of individual read/write/whatever instructions. Other than that, the algorithm is preety much the same.

However, this does not take advantage of the (i1, i2) independence mentioned above. To use that, let us imagine a data structure that includes all the possible executions. This is NOT the data structure that will be used, it's just used to provide a base on which to build. Let us say that two threads interact on a pair (i1, i2) if one of these happen:
* Both access the same data and one of them is a write.
* Both access the same lock and one of them is a lock. (TODO: do I need lock-unlock interactions?)

We will start with one thread and we will remember all its indexes in a chain 0->1->2->...->end1.
Then we will take the second thread. If it does not interact with the first thread on any pair, we will just remember its indexes in a chain. If it does interact, let (ik, jk) be the pairs where the two threads interact. For each (i, j) pair which can be the first to matter (i.e. there is no (p, q) pair with p<=i, q<=j and (i, j) != (p, q)) we will assume that the first thread has executed up to i and the second up to j. Then we will list the indexes 0->1->...->j from the second thread, and we will link this j to i. Note that we may have the same indexes from the second thread in multiple such lists. Then, for each of the (m, n) pairs which can be the first after the (i, j) pairs mentioned above, we will link the end of the j interaction to a chain j->j+1->...->n and we will link n to m. Note that a chain 0->1->...->j will split into multiple chains starting at j. Then we will continue doing this starting at the (m, n) pairs. If, at any point, we reach a (p, q) pair that we explored before, we reuse the end node for the chain ending at q. I.e. if we already have a m->...->q chain with q linked to p and we now want to add a n->...->q chain with q also linked to p, then we add a new chain n->...->q-1, and we link q-1 to the old q index.

Then we will take the third thread and we will ask ourselves which are the first interactions with any of the two threads before, and so on. An index in the third thread can be linked either to an index in the first thread chain, or to a set of indices in the second thread chains. If we can choose between the two links, we will link to the second thread chains [TODO: It's not obvious that this is right]. Now there is a problem of consistency. Let us say that we have two indices (k1, k2) in the third thread, such that k1 is linked to i1 in the first thread, while k2 is linked to j2 in the second thread. We would like to say that we are only interested in the links to j2 which occur after i1. We can first exclude all the j2 occurences in the t2(=thread 2) chains which are forced to occur before i1 (i.e. because they or something after them has a link to something before i1). That may not be trivial, because some of the chains after j2 may be forced to occur before i1, while some may not. However, we might be able to postpone this problem since we can only have the following cases:
* j2 is not the end of a chain
-- the beginnig of its chain is after i1 - good (accept)
-- the beginning of its chain is before i1, but the end is after i1 - good (accept)
-- the end of its chain is before i1 - good (reject);
* j2 is the end of a chain
-- it is after i1 - good (accept)
-- it is before i1 - good (reject)
-- it is simultaneous with i1 - good (accept)
Actually, instead of linking the end of a chain to a set, it is probably better to add separate chains which are linked to the individual indices in that set.
Ok, what happens if k1 is linked to j1, then k2 to i2? We need somehow to only consider executions where i2 can be after j1. But, for each possible j1, we will have a k1 chain. Each of these j1 instances will have its own restricts relative to i2, so we will only be able to continue some of them.

This means that we may need to add to each end of a chain not only its links, but also the restricts for the other threads, unless we are sure that we can infer them. When merging two chains, we will need to take these restricts into account. On the other hand, we may build a good representation (though it may be useless) of all possible executions without these restricts.

TODO: Figure out if we need the restricts or we can live without them.

Now, for each of these chains, we have a precondition and an outcome. We need to figure out how thread execution will work out taking those into account. If, at any point, we find out that we can reach a data access interaction, then we have a race. If we reach a lock interaction, then we have to choose which thread executes first. Actually, we should do this at the data structure building time.

So when we have an interation (i, j) to add which is a lock one, we will add two chains ending in j, one which says (j goes first), another one which says (i goes first). When lock-linking (i, j, k) we will have, for the (i, j) pair, one of the two cases, i or j goes first. Let's say that j has a higher thread index than i. Then, if (i goes first) then we will add only one chain, which agrees with (i goes first). Otherwise, we will add two chains, one which says (j goes first), the other saying (k goes first). Hm, it's not that simple. Or maybe it is.

So, we need to add the locks held in the state. Or reuse the per-thread lock information.

BTW, we also add start-begin and join-end links.

Ok, so we start with the chains at (0,0,...). The state at (0,0,...) is known, so we know for which chains we meet the precondition.

For each of the chains for which the precondition is met, we mark its end as "reachable" and we remember the possible sets of values with which we reach that end [TODO: As with the restricts for the other threads, we may be able to live without these]. Then, for all ends for which all chains ending there were tested, we check the precondition for each chain starting there and, if met, we mark its end as "reachable". And we continue.

* I need to do something for the chains which block in the middle of the chain. Or maybe not.