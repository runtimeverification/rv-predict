:
#	SCCS: @(#)sigtool	1.5 (03/03/31)
#
#	UniSoft Ltd., London, England
#
# Copyright (c) 1998 The Open Group
# All rights reserved.
#
# No part of this source code may be reproduced, stored in a retrieval
# system, or transmitted, in any form or by any means, electronic,
# mechanical, photocopying, recording or otherwise, except as stated in
# the end-user licence agreement, without the prior permission of the
# copyright owners.
# A copy of the end-user licence agreement is contained in the file
# Licence which accompanies this distribution.
# 
# Motif, OSF/1, UNIX and the "X" device are registered trademarks and
# IT DialTone and The Open Group are trademarks of The Open Group in
# the US and other countries.
#
# X/Open is a trademark of X/Open Company Limited in the UK and other
# countries.
#
# ************************************************************************
#
# SCCS:   	@(#)sigtool	1.5 03/03/31 TETware release 3.8
# NAME:		sigtool
# PRODUCT:	TETware
# AUTHOR:	Andrew Dingwall, UniSoft Ltd.
# DATE CREATED:	September 1998
#
# DESCRIPTION:
#	Shell script to generate the signal lists used in a defines.mk
#	file when building the xpg3sh API.
#
#	usage:
#		[CC=cc-name] sh sigtool [cc-options ...]
#
#	This script creates a small C program and compiles it.
#	If the C compiler is not called cc on your system, you should set
#	the CC environment variable to the name of the C compiler.
#
#	On most systems, cc-options are not required.
#	Indeed, since this script looks for the value of NSIG (or _NSIG)
#	in <signal.h>, options that enable ANSI C or feature test macros that
#	restrict the namespace should not be specified.
# 
# MODIFICATIONS:
# 
# ************************************************************************


# don't run this script on a Win32 system
case `uname -s` in
Windows_*)
	echo "$0: Win32 systems do not really support signals" 1>&2
	echo "$0: use the signal values defined in src/defines/msc+mks.mk" 1>&2
	exit 1
	;;
esac

# temporary file names
tmp1_c=tmp$$-1.c
tmp2_c=tmp$$-2.c
tmp3_c=tmp$$-3.c
tmp4=tmp$$-4
tmp5=tmp$$-5

# arrange to clean up on exit
trap 's=$?; rm -f $tmp1_c $tmp2_c $tmp3_c $tmp4 $tmp5; exit $s' 0
trap 'exit $?' 1 2 3 13 15

# lists of signal names
std_sigs1="SIGHUP SIGINT SIGQUIT SIGILL SIGABRT SIGFPE SIGPIPE SIGALRM"
std_sigs2="SIGTERM SIGUSR1 SIGUSR2 SIGTSTP SIGCONT SIGTTIN SIGTTOU"
spec_sigs="SIGKILL SIGCHLD SIGSTOP SIGSEGV"


# generate the signal evaluation program
for sig in $std_sigs1 $std_sigs2
do
	cat <<!EOF
#ifdef $sig
	(void) printf(" %d", $sig);
#else
	(void) printf(" $sig");
#endif
!EOF
done > $tmp1_c

for sig in $spec_sigs
do
	cat <<!EOF
#ifdef $sig
	(void) printf(" %d", $sig);
#else
	(void) printf(" $sig");
#endif
!EOF
done > $tmp2_c

cat > $tmp3_c <<!EOF
#include <stdio.h>
#include <signal.h>
int main()
{
	(void) printf("SH_STD_SIGNALS =");
#include "$tmp1_c"
	(void) printf("\nSH_SPEC_SIGNALS =");
#include "$tmp2_c"
	(void) printf("\nSH_NSIG = ");
#ifdef NSIG
	(void) printf("%d", NSIG);
#else
#  ifdef _NSIG
	(void) printf("%d", _NSIG);
#  else
	(void) printf("NSIG");
#  endif
#endif
	(void) printf("\n");
	return(0);
}
!EOF

# compile the signal evaluation program
${CC:-cc} $* -o $tmp4 $tmp3_c
if test $? -ne 0
then
	echo "$0: can't compile signal evaluation program" 1>&2
	(exit 1)
	exit 1
fi

# generate the awk script
cat > $tmp5 <<!EOF
BEGIN {
	printf("# The following signal values have been generated by sigtool.\n");
	printf("# It is assumed that the shell is capable of trapping all\n");
	printf("# the signals except $spec_sigs\n");
	printf("# If this is not true on your system you will need to edit\n");
	printf("# the values that follow.\n\n");
	errors = 0;
	done_std_sigs = 0;
	done_spec_sigs = 0;
	done_nsig = 0;
}

\$2 != "=" {
	next;
}

\$1 == "SH_STD_SIGNALS" {
	printf("# standard signals:\n");
	printf("# $std_sigs1\n");
	printf("# $std_sigs2\n");
	done_std_sigs = 1;
}

\$1 == "SH_SPEC_SIGNALS" {
	printf("# signals that cannot be handled by the shell:\n");
	printf("# $spec_sigs\n");
	done_spec_sigs = 1;
}

\$1 == "SH_NSIG" {
	printf("# highest signal number supported by the shell + 1\n");
	done_nsig = 1;
}

{
	for (n = 3; n <= NF; n++)
		if (\$n ~ /[^0-9]/) {
			printf("*** cannot determine a value for %s\n", \$n);
			errors++;
		}
	printf("%s\n\n", \$0);
}

END {
	if (errors || !done_std_sigs || !done_spec_sigs || !done_nsig) {
		printf("You will need to supply the values that could not\n");
		printf("be determined automatically by sigtool.\n");
		printf("For details, please refer to the TETware Installation\n");
		printf("Guide for UNIX Operating Systems.\n");
	}
}
!EOF

# finally, generate the signal lists
./$tmp4 | awk -f $tmp5

