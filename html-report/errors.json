{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","loc":{"symbol":"bit_shift_001","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":21,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","loc":{"symbol":"memory_allocation_failure_004_func_001","loc":{"rel_file":"memory_allocation_failure.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/memory_allocation_failure.c","line":96,"column":5,"system_header":false},"locks":[],"language":"C"},"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","loc":{"symbol":"bit_shift_002","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":33,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","loc":{"symbol":"bit_shift_003","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":45,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","loc":{"symbol":"bit_shift_004","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":57,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"The right operand in a bitwise shift is negative.","loc":{"symbol":"bit_shift_005","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":69,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CEB2","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise left shift with a negative second operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. The portable solution if the second operand could be negative is to test whether the operand is positive or negative, and if it is negative, perform a right shift instead of a left shift.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","loc":{"symbol":"bit_shift_006","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":81,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CEB7","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","loc":{"symbol":"memory_allocation_failure_011_func_001","loc":{"rel_file":"memory_allocation_failure.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/memory_allocation_failure.c","line":376,"column":5,"system_header":false},"locks":[],"language":"C"},"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"The right operand in a bitwise shift is negative.","loc":{"symbol":"bit_shift_007","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":93,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CEB6","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise right shift with a negative second operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. The portable solution if the second operand could be negative is to test whether the operand is positive or negative, and if it is negative, perform a left shift instead of a right shift.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","loc":{"symbol":"memory_allocation_failure_012_func_001","loc":{"rel_file":"memory_allocation_failure.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/memory_allocation_failure.c","line":413,"column":5,"system_header":false},"locks":[],"language":"C"},"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","loc":{"symbol":"bit_shift_017","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":236,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","loc":{"symbol":"memory_allocation_failure_013_func_001","loc":{"rel_file":"memory_allocation_failure.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/memory_allocation_failure.c","line":462,"column":5,"system_header":false},"locks":[],"language":"C"},"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","loc":{"symbol":"<file-scope>","loc":{"rel_file":"memory_allocation_failure.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/memory_allocation_failure.c","line":522,"column":1,"system_header":false},"locks":[],"language":"C"},"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","loc":{"symbol":"memory_allocation_failure_015_func_001","loc":{"rel_file":"memory_allocation_failure.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/memory_allocation_failure.c","line":635,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","loc":{"symbol":"data_lost_011","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":144,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Dereferencing a pointer past the end of an array.","loc":{"symbol":"overrun_st_012","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":158,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Signed integer overflow.","loc":{"symbol":"data_overflow_023","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":318,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","loc":{"symbol":"data_underflow_006","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":81,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_005_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":111,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_006_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":137,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_007_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":171,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_008_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":214,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_009_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":258,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_010_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":300,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_011_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":332,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Division by 0.","loc":{"symbol":"zero_division_001","loc":{"rel_file":"zero_division.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/zero_division.c","line":22,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CEMX1","citations":[{"document":"C11","section":"6.5.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 45"},{"document":"CERT-C","section":"INT33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the second operand of a division operation is 0, the behavior is undefined. In practice this generally leads to abnormal program termination, but it can also go into a trap handler or raise a signal instead, depending on the platform. It is also possible on platforms with IEEE 754 floats to silently continue with an infinite or NaN value on floating point division by zero, corrupting future arithmetic data. The solution is that if the second operand can be zero, to check for zero division explicitly and handle it separately.\n"}
{"description":"Division by 0.","loc":{"symbol":"zero_division_002","loc":{"rel_file":"zero_division.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/zero_division.c","line":33,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CEMX1","citations":[{"document":"C11","section":"6.5.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 45"},{"document":"CERT-C","section":"INT33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the second operand of a division operation is 0, the behavior is undefined. In practice this generally leads to abnormal program termination, but it can also go into a trap handler or raise a signal instead, depending on the platform. It is also possible on platforms with IEEE 754 floats to silently continue with an infinite or NaN value on floating point division by zero, corrupting future arithmetic data. The solution is that if the second operand can be zero, to check for zero division explicitly and handle it separately.\n"}
{"description":"Modulus by 0.","loc":{"symbol":"zero_division_003","loc":{"rel_file":"zero_division.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/zero_division.c","line":46,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CEMX2","citations":[{"document":"C11","section":"6.5.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 45"},{"document":"CERT-C","section":"INT33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the second operand of an integer modulus operation is 0, the behavior is undefined. In practice this generally leads to abnormal program termination, but it can also go into a trap handler or raise a signal instead, depending on the platform. The solution is that if the second operand can be zero, to check for zero modulus explicitly and handle it separately.\n"}
{"description":"Division by 0.","loc":{"symbol":"zero_division_008","loc":{"rel_file":"zero_division.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/zero_division.c","line":128,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CEMX1","citations":[{"document":"C11","section":"6.5.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 45"},{"document":"CERT-C","section":"INT33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the second operand of a division operation is 0, the behavior is undefined. In practice this generally leads to abnormal program termination, but it can also go into a trap handler or raise a signal instead, depending on the platform. It is also possible on platforms with IEEE 754 floats to silently continue with an infinite or NaN value on floating point division by zero, corrupting future arithmetic data. The solution is that if the second operand can be zero, to check for zero division explicitly and handle it separately.\n"}
{"description":"Identifier invalid_extern_001_glb_006_str declared with incompatible types in different translation units.","loc":{"symbol":"<file-scope>","loc":{"rel_file":"invalid_extern_1.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/invalid_extern_1.c","line":24,"column":1,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-TIN1","citations":[{"document":"C11","section":"6.2.7","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 15"},{"document":"CERT-C","section":"DCL23-C"},{"document":"CERT-C","section":"DCL40-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior for the same identifier to be declared with different, incompatible types, in different translation units. In practice, this can lead to incorrect accesses on shared data that corrupts the value of a shared variable, or to further undefined behavior such as violations of strict aliasing, function call compatibility, etc. The solution is that every translation unit that declares an object with excternal linkage that denotes the same object must declare it with compatible types.\n"}
{"description":"Identifier invalid_extern_001_glb_buf declared with incompatible types in different translation units.","loc":{"symbol":"<file-scope>","loc":{"rel_file":"invalid_extern_1.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/invalid_extern_1.c","line":13,"column":1,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-TIN1","citations":[{"document":"C11","section":"6.2.7","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 15"},{"document":"CERT-C","section":"DCL23-C"},{"document":"CERT-C","section":"DCL40-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior for the same identifier to be declared with different, incompatible types, in different translation units. In practice, this can lead to incorrect accesses on shared data that corrupts the value of a shared variable, or to further undefined behavior such as violations of strict aliasing, function call compatibility, etc. The solution is that every translation unit that declares an object with excternal linkage that denotes the same object must declare it with compatible types.\n"}
{"description":"Identifier invalid_extern_001_glb_float declared with incompatible types in different translation units.","loc":{"symbol":"<file-scope>","loc":{"rel_file":"invalid_extern_1.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/invalid_extern_1.c","line":14,"column":1,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-TIN1","citations":[{"document":"C11","section":"6.2.7","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 15"},{"document":"CERT-C","section":"DCL23-C"},{"document":"CERT-C","section":"DCL40-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior for the same identifier to be declared with different, incompatible types, in different translation units. In practice, this can lead to incorrect accesses on shared data that corrupts the value of a shared variable, or to further undefined behavior such as violations of strict aliasing, function call compatibility, etc. The solution is that every translation unit that declares an object with excternal linkage that denotes the same object must declare it with compatible types.\n"}
{"description":"Identifier invalid_extern_001_glb_var3 declared with incompatible types in different translation units.","loc":{"symbol":"<file-scope>","loc":{"rel_file":"invalid_extern_1.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/invalid_extern_1.c","line":15,"column":1,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-TIN1","citations":[{"document":"C11","section":"6.2.7","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 15"},{"document":"CERT-C","section":"DCL23-C"},{"document":"CERT-C","section":"DCL40-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior for the same identifier to be declared with different, incompatible types, in different translation units. In practice, this can lead to incorrect accesses on shared data that corrupts the value of a shared variable, or to further undefined behavior such as violations of strict aliasing, function call compatibility, etc. The solution is that every translation unit that declares an object with excternal linkage that denotes the same object must declare it with compatible types.\n"}
{"description":"Identifier invalid_extern_001_glb_var4 declared with incompatible types in different translation units.","loc":{"symbol":"<file-scope>","loc":{"rel_file":"invalid_extern_1.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/invalid_extern_1.c","line":16,"column":1,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-TIN1","citations":[{"document":"C11","section":"6.2.7","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 15"},{"document":"CERT-C","section":"DCL23-C"},{"document":"CERT-C","section":"DCL40-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior for the same identifier to be declared with different, incompatible types, in different translation units. In practice, this can lead to incorrect accesses on shared data that corrupts the value of a shared variable, or to further undefined behavior such as violations of strict aliasing, function call compatibility, etc. The solution is that every translation unit that declares an object with excternal linkage that denotes the same object must declare it with compatible types.\n"}
{"description":"Identifier invalid_extern_001_glb_var5 declared with incompatible types in different translation units.","loc":{"symbol":"<file-scope>","loc":{"rel_file":"invalid_extern_1.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/invalid_extern_1.c","line":17,"column":1,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-TIN1","citations":[{"document":"C11","section":"6.2.7","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 15"},{"document":"CERT-C","section":"DCL23-C"},{"document":"CERT-C","section":"DCL40-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior for the same identifier to be declared with different, incompatible types, in different translation units. In practice, this can lead to incorrect accesses on shared data that corrupts the value of a shared variable, or to further undefined behavior such as violations of strict aliasing, function call compatibility, etc. The solution is that every translation unit that declares an object with excternal linkage that denotes the same object must declare it with compatible types.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_005_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/02.wo_Defects/littlemem_st.c","line":111,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_006_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/02.wo_Defects/littlemem_st.c","line":137,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_007_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/02.wo_Defects/littlemem_st.c","line":171,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_008_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/02.wo_Defects/littlemem_st.c","line":214,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_009_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/02.wo_Defects/littlemem_st.c","line":258,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_010_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/02.wo_Defects/littlemem_st.c","line":300,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","loc":{"symbol":"littlemem_st_011_func_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/02.wo_Defects/littlemem_st.c","line":332,"column":2,"system_header":false},"locks":[],"language":"C"},"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"bit_shift_005","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":69,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"bit_shift_main","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":269,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":29,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Potential negative zero produced via bitwise operations (this could be a false positive).","traces":[{"frames":[{"symbol":"bit_shift_005","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":69,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"bit_shift_main","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":269,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":29,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEB12","citations":[{"document":"C11","section":"6.2.6.2","paragraph":"4"},{"document":"C11","section":"J.2","paragraph":"1 item 14"},{"document":"CERT-C","section":"INT13-C"},{"document":"CERT-C","section":"MSC15-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","traces":[{"frames":[{"symbol":"bit_shift_008","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":106,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"bit_shift_main","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":284,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":29,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","traces":[{"frames":[{"symbol":"bit_shift_009","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":120,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"bit_shift_main","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":289,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":29,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","traces":[{"frames":[{"symbol":"bit_shift_010","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":133,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"bit_shift_main","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":294,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":29,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","traces":[{"frames":[{"symbol":"bit_shift_011","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":146,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"bit_shift_main","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":299,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":29,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","traces":[{"frames":[{"symbol":"bit_shift_012","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":163,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"bit_shift_main","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":304,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":29,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","traces":[{"frames":[{"symbol":"bit_shift_013_func_001","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":175,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"bit_shift_013","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":181,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"bit_shift_main","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":309,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":29,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","traces":[{"frames":[{"symbol":"bit_shift_014","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":193,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"bit_shift_main","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":314,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":29,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","traces":[{"frames":[{"symbol":"bit_shift_015","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":208,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"bit_shift_main","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":319,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":29,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"The right operand in a bitwise shift is greater than or equal to the bit width of the left operand.","traces":[{"frames":[{"symbol":"bit_shift_016","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":225,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"bit_shift_main","loc":{"rel_file":"bit_shift.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/bit_shift.c","line":324,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":29,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEB3","citations":[{"document":"C11","section":"6.5.7","paragraph":"3"},{"document":"C11","section":"J.2","paragraph":"1 item 51"},{"document":"CERT-C","section":"INT34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined to perform a bitwise shift with a second operand greater than or equal to the bit width of the first operand. The behavior of such a shift operation is architecture specific and depends on the code generated for the shift expression, and is therefore not portable and may trigger incorrect behavior on some platforms. Because a bitshift of such a width would generate a constant value regardless of the first operand, it is generally not necessary to write such code, and the presence of such an error generally indicates a logic error in the computation of the value of the second operand; however, in the case where such a trivial shift operation is in fact desired, the solution is to check whether the second operand is greater than or equal to the bit width of the first operand, and if it is, perform two successive shifts whose widths sum to the bit width of the first operand.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_001","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":26,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":620,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_001","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":26,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":620,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_002","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":625,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_002","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":625,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_003","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":61,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":630,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Reading outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_003","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":61,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":630,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO7","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"},{"document":"CERT-C","section":"STR32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the second worst case of buffer overflow vulnerability: the read that has occurred has read from a completely separate region of memory. In the worst case, this could result in sensitive information such as private keys and passwords being output to the user, which could lead to entire systems being compromised by the attacker. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_003","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":61,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":630,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_004","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":76,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":635,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_004","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":76,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":635,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_005","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":93,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":640,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_005","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":93,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":640,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_006","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":111,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":645,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_006","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":111,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":645,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_007","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":129,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":650,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_007","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":129,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":650,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_008","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":151,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":655,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_008","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":151,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":655,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_009","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":660,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_009","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":660,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_009","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":660,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_009","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":660,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_010","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":197,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":665,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_010","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":197,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":665,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_011","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":217,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":670,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_011","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":217,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":670,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_011","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":217,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":670,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_012","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":232,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":675,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_012","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":232,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":675,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_013","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":247,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":680,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_013","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":247,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":680,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_014","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":262,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":685,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_014","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":262,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":685,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_014","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":262,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":685,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_014","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":262,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":685,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_015","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":277,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":690,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_015","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":277,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":690,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_016","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":297,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":695,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_016","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":297,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":695,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_017_func_001","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":311,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_017","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":318,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":700,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_017_func_001","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":311,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_017","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":318,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":700,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_018","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":332,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":705,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Reading outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_018","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":332,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":705,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO7","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"},{"document":"CERT-C","section":"STR32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the second worst case of buffer overflow vulnerability: the read that has occurred has read from a completely separate region of memory. In the worst case, this could result in sensitive information such as private keys and passwords being output to the user, which could lead to entire systems being compromised by the attacker. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_018","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":332,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":705,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_019","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":349,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":710,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_019","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":349,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":710,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_020","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":368,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":715,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_020","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":368,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":715,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_021","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":386,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":720,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_021","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":386,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":720,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_022","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":402,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":725,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_022","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":402,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":725,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_023","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":421,"column":7,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":730,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_023","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":421,"column":7,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":730,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_023","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":422,"column":8,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":730,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_023","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":422,"column":8,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":730,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_024_func_001","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":434,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_024","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":441,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":735,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_024_func_001","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":434,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_024","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":441,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":735,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_025","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":461,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":740,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_025","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":461,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":740,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_026","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":479,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":745,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_026","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":479,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":745,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_026","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":479,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":745,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_026","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":479,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":745,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_027","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":495,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":750,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_027","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":495,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":750,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_027","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":495,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":750,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_027","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":495,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":750,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_028","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":513,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":755,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Reading outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_028","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":513,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":755,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO7","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"},{"document":"CERT-C","section":"STR32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the second worst case of buffer overflow vulnerability: the read that has occurred has read from a completely separate region of memory. In the worst case, this could result in sensitive information such as private keys and passwords being output to the user, which could lead to entire systems being compromised by the attacker. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_028","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":513,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":755,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_029","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":531,"column":7,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":760,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_029","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":531,"column":7,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":760,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_029","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":531,"column":7,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":760,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_029","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":531,"column":7,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":760,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_030","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":558,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":765,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_030","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":558,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":765,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_031","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":579,"column":7,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":770,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_031","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":579,"column":7,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":770,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_032","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":606,"column":7,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":775,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_032","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":606,"column":7,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":775,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_overrun_032","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":606,"column":7,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_overrun_main","loc":{"rel_file":"buffer_overrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_overrun_dynamic.c","line":775,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":35,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_001","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":28,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":795,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_001","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":28,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":795,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_001","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":28,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":795,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_002","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":44,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":800,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_002","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":44,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":800,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_002","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":44,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":800,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_002","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":44,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":800,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_003","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":64,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":805,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_003","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":64,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":805,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_003","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":64,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":805,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_003","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":64,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":805,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_003","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":64,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":805,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_004","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":79,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":810,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_004","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":79,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":810,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_004","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":79,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":810,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_004","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":79,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":810,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_005","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":96,"column":10,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":815,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_005","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":96,"column":10,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":815,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_005","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":96,"column":10,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":815,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_005","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":96,"column":10,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":815,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_006","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":114,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":820,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_006","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":114,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":820,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_006","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":114,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":820,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_006","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":114,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":820,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_007","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":132,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":825,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_007","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":132,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":825,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_007","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":132,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":825,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_007","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":132,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":825,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_008","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":154,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":830,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_008","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":154,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":830,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_008","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":154,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":830,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int *) not compatible with the effective type of the object being accessed (int * [5]).","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_008","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":154,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":830,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_008","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":154,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":830,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a null pointer.","traces":[{"frames":[{"symbol":"dynamic_buffer_underrun_008","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":154,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"dynamic_buffer_underrun_main","loc":{"rel_file":"buffer_underrun_dynamic.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/buffer_underrun_dynamic.c","line":830,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":41,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER3","citations":[{"document":"C11","section":"6.5.3.2","paragraph":"4"},{"document":"C11","section":"J.2","paragraph":"1 item 43"},{"document":"CERT-C","section":"EXP34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, dereferencing a null pointer is undefined behavior. In practice this generally leads to abnormal program termination, but it can also silently cause incorrect behavior at runtime if the deference operation does not compile into a read or write instruction at that address. This can occur if a null function pointer is dereferenced, because the subsequent lvalue to rvalue conversion makes the two operations cancel into a nop when compiled by many compilers. It can also occur if a struct field is dereferenced on a null struct pointer, an idiom sometimes used by inexperienced C developers to compute the offset of the struct field. However, this in fact computes the address of the struct field as an offset of the null pointer, which makes this idiom dangerous because the null pointer is not guaranteed to be the same as the zero address. Using a null pointer dereference in this fashion thus can lead to buffer overflow vulnerabilities on some platforms because it will not compute the correct offset. Developers in this case are advised to use the offsetof macro. But generally, the solution is to avoid dereferencing a pointer which may be null without first checking whether it is in fact null, and performing error handling.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"data_lost_001","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":21,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_lost_main","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":268,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":59,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"data_lost_002","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":33,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_lost_main","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":273,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":59,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"data_lost_003","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":45,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_lost_main","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":278,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":59,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to integer from float outside the range that can be represented.","traces":[{"frames":[{"symbol":"data_lost_004","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":57,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_lost_main","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":283,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":59,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV3","citations":[{"document":"C11","section":"6.3.1.4","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 17"},{"document":"CERT-C","section":"FLP34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, conversion from a floating type to an integer type results in the integral part of the float with the fractional part truncated. However, if the truncated mathematical value cannot be represented in the resulting integer type, the behavior is undefined. In practice this can have similar consequences to an integer or floating point overflow, in which the resulting value of the variable is not as expected, and therefore a buffer overflow vulnerability can occur if the value is used to compute a memory address. The solution is to ensure that values of floating point numbers that are converted to integers are always within the bounds of the resulting integer type, either based on their range of possible values, or by explicitly checking prior to the conversion.\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_lost_004","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":57,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_lost_main","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":283,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":59,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Conversion to integer from float outside the range that can be represented.","traces":[{"frames":[{"symbol":"data_lost_005","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":69,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_lost_main","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":288,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":59,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV3","citations":[{"document":"C11","section":"6.3.1.4","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 17"},{"document":"CERT-C","section":"FLP34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, conversion from a floating type to an integer type results in the integral part of the float with the fractional part truncated. However, if the truncated mathematical value cannot be represented in the resulting integer type, the behavior is undefined. In practice this can have similar consequences to an integer or floating point overflow, in which the resulting value of the variable is not as expected, and therefore a buffer overflow vulnerability can occur if the value is used to compute a memory address. The solution is to ensure that values of floating point numbers that are converted to integers are always within the bounds of the resulting integer type, either based on their range of possible values, or by explicitly checking prior to the conversion.\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_lost_005","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":69,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_lost_main","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":288,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":59,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"data_lost_005","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":70,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_lost_main","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":288,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":59,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Floating-point value outside the range of values that can be represented after conversion.","traces":[{"frames":[{"symbol":"data_lost_006","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":81,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_lost_main","loc":{"rel_file":"data_lost.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_lost.c","line":293,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":59,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV4","citations":[{"document":"C11","section":"6.3.1.5","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 18"},{"document":"CERT-C","section":"FLP34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if a floating point value is converted to another floating type, and the mathematical value of the float is greater than the maximum positive value for the resulting type, or less than the minimum negative value for the resulting type, the behavior is undefined. In practice this has similar consequences to a floating-point overflow, and can lead to propagating arithmetic errors throughout any floating-point computation that uses the result value of the conversion. On systems supporting IEEE 754 arithmetic, the result of such a conversion is either a positive or negative infinite value, or else SIGFPE is raised. Thus, depending on how the floating point exceptions are configured in your application, and depending on your signal handler's behavior, this error can also lead to abnormal program termination. In general, code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"data_overflow_001","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":24,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":362,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"data_overflow_002","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":36,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":367,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_003","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":48,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":372,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_004","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":60,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":377,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"data_overflow_004","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":61,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":377,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"data_overflow_009","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":125,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":402,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_011","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":152,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":412,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_012","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":165,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":417,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_013","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":177,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":422,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_014","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":190,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":427,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_015","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":204,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":432,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_016","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":216,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":437,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_017","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":228,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":442,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_018","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":245,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":447,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_019_func_001","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":257,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_019","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":263,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":452,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_020","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":275,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":457,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_021","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":290,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":462,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_overflow_022","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":307,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":467,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Floating-point overflow.","traces":[{"frames":[{"symbol":"data_overflow_024","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":334,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":477,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV12","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"FLP32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a floating point result can not be represented in the result type, the behavior is undefined. In practice, this error can lead to propagating arithmetic errors throughout any floating-point computation that uses the result of the expression. On systems supporting IEEE 754 arithmetic, the resdult of such an expression is either a positive or negative infinite value, or else SIGFPE is raised. Thus, depending on how the floatingb point exceptions are configured in your application, and depending on your signal handler's behavior, this error can also lead to abnormal program termination. In general, code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n"}
{"description":"Floating-point overflow.","traces":[{"frames":[{"symbol":"data_overflow_025","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":350,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_overflow_main","loc":{"rel_file":"data_overflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_overflow.c","line":482,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":65,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV12","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"FLP32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a floating point result can not be represented in the result type, the behavior is undefined. In practice, this error can lead to propagating arithmetic errors throughout any floating-point computation that uses the result of the expression. On systems supporting IEEE 754 arithmetic, the resdult of such an expression is either a positive or negative infinite value, or else SIGFPE is raised. Thus, depending on how the floatingb point exceptions are configured in your application, and depending on your signal handler's behavior, this error can also lead to abnormal program termination. In general, code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_underflow_001","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":20,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_underflow_main","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":183,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":71,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"data_underflow_002","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":33,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_underflow_main","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":188,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":71,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_underflow_003","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":45,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_underflow_main","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":193,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":71,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_underflow_004","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":58,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_underflow_main","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":198,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":71,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_underflow_005","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":70,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_underflow_main","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":203,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":71,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"data_underflow_009","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":123,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_underflow_main","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":223,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":71,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_underflow_010","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":140,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_underflow_main","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":228,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":71,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_underflow_011_func_001","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":152,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_underflow_011","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":158,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_underflow_main","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":233,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":71,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"data_underflow_012","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":170,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"data_underflow_main","loc":{"rel_file":"data_underflow.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/data_underflow.c","line":238,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":71,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"double_free_001","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":22,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_main","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":235,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":95,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"double_free_002","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":43,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_main","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":240,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":95,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"double_free_003","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":64,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_main","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":245,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":95,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"double_free_004","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":87,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_main","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":250,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":95,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"double_free_005","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":100,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_main","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":255,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":95,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"double_free_006","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":115,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_main","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":260,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":95,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"double_free_007","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":131,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_main","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":265,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":95,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"free","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":149,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_008","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":149,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_main","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":270,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":95,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"double_free_009","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":168,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_main","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":275,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":95,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"double_free_010","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":187,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_main","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":280,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":95,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"double_free_011","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":204,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_main","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":285,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":95,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"double_free_012","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":222,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_free_main","loc":{"rel_file":"double_free.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_free.c","line":290,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":95,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Attempting to lock a PTHREAD_MUTEX_DEFAULT mutex that is already locked by the current thread.","traces":[{"frames":[{"symbol":"pthread_mutex_lock","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":42,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_001_tsk_001","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":42,"column":2,"system_header":false},"locks":[],"language":"C"}]},{"description":"Locked here:","frames":[{"symbol":"pthread_mutex_lock","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":40,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_001_tsk_001","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":40,"column":2,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-PTHREAD4","citations":[{"document":"CERT-C","section":"MSC15-C"},{"document":"POSIX 2008","section":"pthread_mutex_lock"}],"friendly_cat":"Undefined behavior","long_desc":"According to POSIX 2008, it is undefined behavior to lock a mutex initialized with PTHREAD_MUTEX_DEFAULT in a thread in which the mutex is already locked. In practice this can lead to deadlocking the thread and preventing program execution from continuing. The solution when attempting to lock a mutex that may already be locked by the current thread is to either use a PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE mutex, or else call pthread_mutex_trylock in order to avoi undefined behavior if the mutex is already locked by the current thread.\n"}
{"description":"Destroying a locked mutex.","traces":[{"frames":[{"symbol":"pthread_mutex_destroy","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":58,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_001","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":58,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_main","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":241,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":101,"column":3,"system_header":false},"locks":[],"language":"C"}]},{"description":"Locked here:","frames":[{"symbol":"pthread_mutex_lock","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":40,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_001_tsk_001","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":40,"column":2,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-PTHREAD2","citations":[{"document":"CERT-C","section":"CON31-C"},{"document":"POSIX 2008","section":"pthread_mutex_destroy"}],"friendly_cat":"Undefined behavior","long_desc":"According to POSIX 2008, it is undefined behavior to call pthread_mutex_destroy on a mutex which is currently locked. In practice this may prevent any threads that are waiting on that mutex from waking correctly, leading to deadlock or other concurrency bugs in the application. The solution is to always unlock any mutexes prior to destroying them.\n"}
{"description":"Attempting to lock a PTHREAD_MUTEX_DEFAULT mutex that is already locked by the current thread.","traces":[{"frames":[{"symbol":"pthread_mutex_lock","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":94,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_002_tsk_001","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":94,"column":5,"system_header":false},"locks":[],"language":"C"}]},{"description":"Locked here:","frames":[{"symbol":"pthread_mutex_lock","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":91,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_002_tsk_001","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":91,"column":2,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-PTHREAD4","citations":[{"document":"CERT-C","section":"MSC15-C"},{"document":"POSIX 2008","section":"pthread_mutex_lock"}],"friendly_cat":"Undefined behavior","long_desc":"According to POSIX 2008, it is undefined behavior to lock a mutex initialized with PTHREAD_MUTEX_DEFAULT in a thread in which the mutex is already locked. In practice this can lead to deadlocking the thread and preventing program execution from continuing. The solution when attempting to lock a mutex that may already be locked by the current thread is to either use a PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE mutex, or else call pthread_mutex_trylock in order to avoi undefined behavior if the mutex is already locked by the current thread.\n"}
{"description":"Attempting to lock a PTHREAD_MUTEX_DEFAULT mutex that is already locked by the current thread.","traces":[{"frames":[{"symbol":"pthread_mutex_lock","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":141,"column":1,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_003_func_001","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":141,"column":1,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_003_tsk_001","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":153,"column":5,"system_header":false},"locks":[],"language":"C"}]},{"description":"Locked here:","frames":[{"symbol":"pthread_mutex_lock","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":150,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_003_tsk_001","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":150,"column":2,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-PTHREAD4","citations":[{"document":"CERT-C","section":"MSC15-C"},{"document":"POSIX 2008","section":"pthread_mutex_lock"}],"friendly_cat":"Undefined behavior","long_desc":"According to POSIX 2008, it is undefined behavior to lock a mutex initialized with PTHREAD_MUTEX_DEFAULT in a thread in which the mutex is already locked. In practice this can lead to deadlocking the thread and preventing program execution from continuing. The solution when attempting to lock a mutex that may already be locked by the current thread is to either use a PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE mutex, or else call pthread_mutex_trylock in order to avoi undefined behavior if the mutex is already locked by the current thread.\n"}
{"description":"Destroying a locked mutex.","traces":[{"frames":[{"symbol":"pthread_mutex_destroy","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":167,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_003","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":167,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_main","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":251,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":101,"column":3,"system_header":false},"locks":[],"language":"C"}]},{"description":"Locked here:","frames":[{"symbol":"pthread_mutex_lock","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":150,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_lock_003_tsk_001","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":150,"column":2,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-PTHREAD2","citations":[{"document":"CERT-C","section":"CON31-C"},{"document":"POSIX 2008","section":"pthread_mutex_destroy"}],"friendly_cat":"Undefined behavior","long_desc":"According to POSIX 2008, it is undefined behavior to call pthread_mutex_destroy on a mutex which is currently locked. In practice this may prevent any threads that are waiting on that mutex from waking correctly, leading to deadlock or other concurrency bugs in the application. The solution is to always unlock any mutexes prior to destroying them.\n"}
{"description":"'printf': Mismatch between the type expected by the conversion specifier %u and the type of the argument.","traces":[{"frames":[{"symbol":"printf","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":199,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"Thread3","loc":{"rel_file":"double_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_lock.c","line":199,"column":4,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STDIO1","citations":[{"document":"C11","section":"7.21.6.1","paragraph":"9"},{"document":"C11","section":"J.2","paragraph":"1 item 153"},{"document":"CERT-C","section":"FIO47-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior if an argument passed to a format action for fprintf, printf, etc. is of a type different than that specified by the standard. In practice this can lead to incorrect data printed or even invalid memory accesses, depending on the platform and the implementation of the format functions. Common cases where this constraint is violated include passing a signed value to the %x conversion, or a pointer other than a pointer to void to the %p specifier. However, any type mismatch between the type of the argument and the type specified by the standard constitutes undefined behavior. The solution is to always convert the argument to the necessary type prior to passing it to the function.\n"}
{"description":"Attempting to unlock a PTHREAD_MUTEX_DEFAULT or PTHREAD_MUTEX_NORMAL mutex which is not robust and which has not been locked by the current thread.","traces":[{"frames":[{"symbol":"pthread_mutex_unlock","loc":{"rel_file":"double_release.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_release.c","line":34,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_release_001_tsk_001","loc":{"rel_file":"double_release.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_release.c","line":34,"column":5,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-PTHREAD6","citations":[{"document":"CERT-C","section":"POS48-C"},{"document":"POSIX 2008","section":"pthread_mutex_lock"}],"friendly_cat":"Undefined behavior","long_desc":"According to POSIX 2008, it is undefined behavior to attempt to unlock a PTHREAD_MUTEX_DEFAULT or PTHREAD_MUTEX_NORMAL mutex which was not initialized as robust and which was not already locked by the current thread. In practice this could result in an error being returned, or it could result in corruption of the mutex, leading to incorrect synchronization and concurrency bugs. The solution is to either use a robust mutex, a PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE mutex, or to avoid calling pthread_mutex_unlock unless it is known that the current thread holds the mutex. \n"}
{"description":"Attempting to unlock a PTHREAD_MUTEX_DEFAULT or PTHREAD_MUTEX_NORMAL mutex which is not robust and which has not been locked by the current thread.","traces":[{"frames":[{"symbol":"pthread_mutex_unlock","loc":{"rel_file":"double_release.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_release.c","line":35,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_release_001_tsk_001","loc":{"rel_file":"double_release.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_release.c","line":35,"column":5,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-PTHREAD6","citations":[{"document":"CERT-C","section":"POS48-C"},{"document":"POSIX 2008","section":"pthread_mutex_lock"}],"friendly_cat":"Undefined behavior","long_desc":"According to POSIX 2008, it is undefined behavior to attempt to unlock a PTHREAD_MUTEX_DEFAULT or PTHREAD_MUTEX_NORMAL mutex which was not initialized as robust and which was not already locked by the current thread. In practice this could result in an error being returned, or it could result in corruption of the mutex, leading to incorrect synchronization and concurrency bugs. The solution is to either use a robust mutex, a PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE mutex, or to avoid calling pthread_mutex_unlock unless it is known that the current thread holds the mutex. \n"}
{"description":"Attempting to unlock a PTHREAD_MUTEX_DEFAULT or PTHREAD_MUTEX_NORMAL mutex which is not robust and which has not been locked by the current thread.","traces":[{"frames":[{"symbol":"pthread_mutex_unlock","loc":{"rel_file":"double_release.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_release.c","line":79,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_release_002_tsk_001","loc":{"rel_file":"double_release.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_release.c","line":79,"column":5,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-PTHREAD6","citations":[{"document":"CERT-C","section":"POS48-C"},{"document":"POSIX 2008","section":"pthread_mutex_lock"}],"friendly_cat":"Undefined behavior","long_desc":"According to POSIX 2008, it is undefined behavior to attempt to unlock a PTHREAD_MUTEX_DEFAULT or PTHREAD_MUTEX_NORMAL mutex which was not initialized as robust and which was not already locked by the current thread. In practice this could result in an error being returned, or it could result in corruption of the mutex, leading to incorrect synchronization and concurrency bugs. The solution is to either use a robust mutex, a PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE mutex, or to avoid calling pthread_mutex_unlock unless it is known that the current thread holds the mutex. \n"}
{"description":"Attempting to unlock a PTHREAD_MUTEX_DEFAULT or PTHREAD_MUTEX_NORMAL mutex which is not robust and which has not been locked by the current thread.","traces":[{"frames":[{"symbol":"pthread_mutex_unlock","loc":{"rel_file":"double_release.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_release.c","line":86,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"double_release_002_tsk_002","loc":{"rel_file":"double_release.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/double_release.c","line":86,"column":5,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-PTHREAD6","citations":[{"document":"CERT-C","section":"POS48-C"},{"document":"POSIX 2008","section":"pthread_mutex_lock"}],"friendly_cat":"Undefined behavior","long_desc":"According to POSIX 2008, it is undefined behavior to attempt to unlock a PTHREAD_MUTEX_DEFAULT or PTHREAD_MUTEX_NORMAL mutex which was not initialized as robust and which was not already locked by the current thread. In practice this could result in an error being returned, or it could result in corruption of the mutex, leading to incorrect synchronization and concurrency bugs. The solution is to either use a robust mutex, a PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE mutex, or to avoid calling pthread_mutex_unlock unless it is known that the current thread holds the mutex. \n"}
{"description":"Called free on memory not allocated by malloc, or already freed.","traces":[{"frames":[{"symbol":"free","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":22,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_001","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":22,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_main","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":281,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":119,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STDLIB2","citations":[{"document":"C11","section":"7.22.3.3","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 179"},{"document":"CERT-C","section":"MEM34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to call free on a pointer which does not point to the first byte of a currently allocated region of memory allocated with one of the allocation functions, e.g. malloc. This is the classic double free vulnerability. In practice doing so can corrupt your free lists, leading to memory corruption in the heap and potentially resulting in security vulnerabilities or abnormal program termination. The correct solution is to only call free on a pointer to the first byte of an object of allocated storage during that object's lifetime (i.e., before another call to realloc or free on the same pointer).\n"}
{"description":"Called free on memory not allocated by malloc, or already freed.","traces":[{"frames":[{"symbol":"free","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":36,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_002","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":36,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_main","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":286,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":119,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STDLIB2","citations":[{"document":"C11","section":"7.22.3.3","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 179"},{"document":"CERT-C","section":"MEM34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to call free on a pointer which does not point to the first byte of a currently allocated region of memory allocated with one of the allocation functions, e.g. malloc. This is the classic double free vulnerability. In practice doing so can corrupt your free lists, leading to memory corruption in the heap and potentially resulting in security vulnerabilities or abnormal program termination. The correct solution is to only call free on a pointer to the first byte of an object of allocated storage during that object's lifetime (i.e., before another call to realloc or free on the same pointer).\n"}
{"description":"Called free on memory not allocated by malloc, or already freed.","traces":[{"frames":[{"symbol":"free","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":48,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_003","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":48,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_main","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":291,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":119,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STDLIB2","citations":[{"document":"C11","section":"7.22.3.3","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 179"},{"document":"CERT-C","section":"MEM34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to call free on a pointer which does not point to the first byte of a currently allocated region of memory allocated with one of the allocation functions, e.g. malloc. This is the classic double free vulnerability. In practice doing so can corrupt your free lists, leading to memory corruption in the heap and potentially resulting in security vulnerabilities or abnormal program termination. The correct solution is to only call free on a pointer to the first byte of an object of allocated storage during that object's lifetime (i.e., before another call to realloc or free on the same pointer).\n"}
{"description":"Called free on memory not allocated by malloc, or already freed.","traces":[{"frames":[{"symbol":"free","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":62,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_004","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":62,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_main","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":296,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":119,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STDLIB2","citations":[{"document":"C11","section":"7.22.3.3","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 179"},{"document":"CERT-C","section":"MEM34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to call free on a pointer which does not point to the first byte of a currently allocated region of memory allocated with one of the allocation functions, e.g. malloc. This is the classic double free vulnerability. In practice doing so can corrupt your free lists, leading to memory corruption in the heap and potentially resulting in security vulnerabilities or abnormal program termination. The correct solution is to only call free on a pointer to the first byte of an object of allocated storage during that object's lifetime (i.e., before another call to realloc or free on the same pointer).\n"}
{"description":"Called free on memory not allocated by malloc, or already freed.","traces":[{"frames":[{"symbol":"free","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":86,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_005","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":86,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_main","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":301,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":119,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STDLIB2","citations":[{"document":"C11","section":"7.22.3.3","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 179"},{"document":"CERT-C","section":"MEM34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to call free on a pointer which does not point to the first byte of a currently allocated region of memory allocated with one of the allocation functions, e.g. malloc. This is the classic double free vulnerability. In practice doing so can corrupt your free lists, leading to memory corruption in the heap and potentially resulting in security vulnerabilities or abnormal program termination. The correct solution is to only call free on a pointer to the first byte of an object of allocated storage during that object's lifetime (i.e., before another call to realloc or free on the same pointer).\n"}
{"description":"Called free on memory not allocated by malloc, or already freed.","traces":[{"frames":[{"symbol":"free","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":103,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_006","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":103,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_main","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":306,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":119,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STDLIB2","citations":[{"document":"C11","section":"7.22.3.3","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 179"},{"document":"CERT-C","section":"MEM34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to call free on a pointer which does not point to the first byte of a currently allocated region of memory allocated with one of the allocation functions, e.g. malloc. This is the classic double free vulnerability. In practice doing so can corrupt your free lists, leading to memory corruption in the heap and potentially resulting in security vulnerabilities or abnormal program termination. The correct solution is to only call free on a pointer to the first byte of an object of allocated storage during that object's lifetime (i.e., before another call to realloc or free on the same pointer).\n"}
{"description":"Called free on memory not allocated by malloc, or already freed.","traces":[{"frames":[{"symbol":"free","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":115,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_007","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":115,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_nondynamic_allocated_memory_main","loc":{"rel_file":"free_nondynamic_allocated_memory.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_nondynamic_allocated_memory.c","line":311,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":119,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STDLIB2","citations":[{"document":"C11","section":"7.22.3.3","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 179"},{"document":"CERT-C","section":"MEM34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to call free on a pointer which does not point to the first byte of a currently allocated region of memory allocated with one of the allocation functions, e.g. malloc. This is the classic double free vulnerability. In practice doing so can corrupt your free lists, leading to memory corruption in the heap and potentially resulting in security vulnerabilities or abnormal program termination. The correct solution is to only call free on a pointer to the first byte of an object of allocated storage during that object's lifetime (i.e., before another call to realloc or free on the same pointer).\n"}
{"description":"Null pointer passed to strcpy.","traces":[{"frames":[{"symbol":"strcpy","loc":{"rel_file":"free_null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_null_pointer.c","line":109,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_null_pointer_005","loc":{"rel_file":"free_null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_null_pointer.c","line":109,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_null_pointer_main","loc":{"rel_file":"free_null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_null_pointer.c","line":597,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":125,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STRING1","citations":[{"document":"C11","section":"7.1.4","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 109"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"ARR38-C"},{"document":"CERT-C","section":"EXP34-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if a library function is called with an invalid value for that function, the behavior is undefined. In this case strcpy was called with a null pointer. In practice this will lead to abnormal program termination as memory is accessed at the null pointer address. The solution is to avoid passing null pointers to functions for which they are not explicitly allowed in the standard library, such as strcpy.According to ISO C11, if a library function is called with an invalid value for that function' the behavior is undefined. In this case strcpy was called with a null pointer. In practice this will lead to abnormal program termination as memory is accessed at the null pointer address. The solution is to avoid passing null pointers to functions for which they are not explicitly allowed in the standard library, such as strcpy.\n"}
{"description":"Null pointer passed to strcpy.","traces":[{"frames":[{"symbol":"strcpy","loc":{"rel_file":"free_null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_null_pointer.c","line":146,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_null_pointer_006","loc":{"rel_file":"free_null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_null_pointer.c","line":146,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_null_pointer_main","loc":{"rel_file":"free_null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_null_pointer.c","line":602,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":125,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STRING1","citations":[{"document":"C11","section":"7.1.4","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 109"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"ARR38-C"},{"document":"CERT-C","section":"EXP34-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if a library function is called with an invalid value for that function, the behavior is undefined. In this case strcpy was called with a null pointer. In practice this will lead to abnormal program termination as memory is accessed at the null pointer address. The solution is to avoid passing null pointers to functions for which they are not explicitly allowed in the standard library, such as strcpy.According to ISO C11, if a library function is called with an invalid value for that function' the behavior is undefined. In this case strcpy was called with a null pointer. In practice this will lead to abnormal program termination as memory is accessed at the null pointer address. The solution is to avoid passing null pointers to functions for which they are not explicitly allowed in the standard library, such as strcpy.\n"}
{"description":"Null pointer passed to strcpy.","traces":[{"frames":[{"symbol":"strcpy","loc":{"rel_file":"free_null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_null_pointer.c","line":242,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_null_pointer_008","loc":{"rel_file":"free_null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_null_pointer.c","line":242,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_null_pointer_main","loc":{"rel_file":"free_null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_null_pointer.c","line":612,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":125,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STRING1","citations":[{"document":"C11","section":"7.1.4","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 109"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"ARR38-C"},{"document":"CERT-C","section":"EXP34-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if a library function is called with an invalid value for that function, the behavior is undefined. In this case strcpy was called with a null pointer. In practice this will lead to abnormal program termination as memory is accessed at the null pointer address. The solution is to avoid passing null pointers to functions for which they are not explicitly allowed in the standard library, such as strcpy.According to ISO C11, if a library function is called with an invalid value for that function' the behavior is undefined. In this case strcpy was called with a null pointer. In practice this will lead to abnormal program termination as memory is accessed at the null pointer address. The solution is to avoid passing null pointers to functions for which they are not explicitly allowed in the standard library, such as strcpy.\n"}
{"description":"Dereferencing a null pointer.","traces":[{"frames":[{"symbol":"free_null_pointer_009","loc":{"rel_file":"free_null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_null_pointer.c","line":277,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"free_null_pointer_main","loc":{"rel_file":"free_null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/free_null_pointer.c","line":617,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":125,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER3","citations":[{"document":"C11","section":"6.5.3.2","paragraph":"4"},{"document":"C11","section":"J.2","paragraph":"1 item 43"},{"document":"CERT-C","section":"EXP34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, dereferencing a null pointer is undefined behavior. In practice this generally leads to abnormal program termination, but it can also silently cause incorrect behavior at runtime if the deference operation does not compile into a read or write instruction at that address. This can occur if a null function pointer is dereferenced, because the subsequent lvalue to rvalue conversion makes the two operations cancel into a nop when compiled by many compilers. It can also occur if a struct field is dereferenced on a null struct pointer, an idiom sometimes used by inexperienced C developers to compute the offset of the struct field. However, this in fact computes the address of the struct field as an offset of the null pointer, which makes this idiom dangerous because the null pointer is not guaranteed to be the same as the zero address. Using a null pointer dereference in this fashion thus can lead to buffer overflow vulnerabilities on some platforms because it will not compute the correct offset. Developers in this case are advised to use the offsetof macro. But generally, the solution is to avoid dereferencing a pointer which may be null without first checking whether it is in fact null, and performing error handling.\n"}
{"description":"Attempt to call the function func_pointer_001_func_001 through a pointer with incompatible type.","traces":[{"frames":[{"symbol":"func_pointer_001","loc":{"rel_file":"func_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/func_pointer.c","line":42,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"func_pointer_main","loc":{"rel_file":"func_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/func_pointer.c","line":619,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":131,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EFNC1","citations":[{"document":"C11","section":"6.5.2.2","paragraph":"9"},{"document":"C11","section":"J.2","paragraph":"1 items 26 and 41"},{"document":"CERT-C","section":"DCL40-C"},{"document":"CERT-C","section":"EXP37-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, It is undefined behavior to call a function via a function pointer if the type of the function is not compatible with the type of the pointer. This can occur when function pointers are converted to another type, e.g. through a void pointer. In practice this could lead to buffer overflow vulnerabilities and stack corruption because the instructions executed to call the function would be incompatible with the calling convention of the function being called. The solution is to always track the type of function pointers even when converted to another type, and ensure that they are not called via a value of an incompatible type to the function pointed to.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"invalid_memory_access_001","loc":{"rel_file":"invalid_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/invalid_memory_access.c","line":45,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"invalid_memory_access_main","loc":{"rel_file":"invalid_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/invalid_memory_access.c","line":668,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":167,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Dereferencing a null pointer.","traces":[{"frames":[{"symbol":"invalid_memory_access_001","loc":{"rel_file":"invalid_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/invalid_memory_access.c","line":45,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"invalid_memory_access_main","loc":{"rel_file":"invalid_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/invalid_memory_access.c","line":668,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":167,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER3","citations":[{"document":"C11","section":"6.5.3.2","paragraph":"4"},{"document":"C11","section":"J.2","paragraph":"1 item 43"},{"document":"CERT-C","section":"EXP34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, dereferencing a null pointer is undefined behavior. In practice this generally leads to abnormal program termination, but it can also silently cause incorrect behavior at runtime if the deference operation does not compile into a read or write instruction at that address. This can occur if a null function pointer is dereferenced, because the subsequent lvalue to rvalue conversion makes the two operations cancel into a nop when compiled by many compilers. It can also occur if a struct field is dereferenced on a null struct pointer, an idiom sometimes used by inexperienced C developers to compute the offset of the struct field. However, this in fact computes the address of the struct field as an offset of the null pointer, which makes this idiom dangerous because the null pointer is not guaranteed to be the same as the zero address. Using a null pointer dereference in this fashion thus can lead to buffer overflow vulnerabilities on some platforms because it will not compute the correct offset. Developers in this case are advised to use the offsetof macro. But generally, the solution is to avoid dereferencing a pointer which may be null without first checking whether it is in fact null, and performing error handling.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","traces":[{"frames":[{"symbol":"littlemem_st_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":35,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":362,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Type of lvalue (struct <anonymous>) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":36,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":362,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":36,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":362,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Reading outside the bounds of an object.","traces":[{"frames":[{"symbol":"littlemem_st_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":36,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":362,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO7","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"},{"document":"CERT-C","section":"STR32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the second worst case of buffer overflow vulnerability: the read that has occurred has read from a completely separate region of memory. In the worst case, this could result in sensitive information such as private keys and passwords being output to the user, which could lead to entire systems being compromised by the attacker. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"littlemem_st_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":36,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":362,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Type of lvalue (struct <anonymous>) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":37,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":362,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":37,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":362,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Reading outside the bounds of an object.","traces":[{"frames":[{"symbol":"littlemem_st_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":37,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":362,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO7","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"},{"document":"CERT-C","section":"STR32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the second worst case of buffer overflow vulnerability: the read that has occurred has read from a completely separate region of memory. In the worst case, this could result in sensitive information such as private keys and passwords being output to the user, which could lead to entire systems being compromised by the attacker. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"littlemem_st_001","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":37,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":362,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","traces":[{"frames":[{"symbol":"littlemem_st_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":54,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":367,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Type of lvalue (struct <anonymous>) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":55,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":367,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":55,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":367,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"littlemem_st_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":55,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":367,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","traces":[{"frames":[{"symbol":"littlemem_st_003","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":72,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":372,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Type of lvalue (union <anonymous>) not compatible with the effective type of the object being accessed (char [2]).","traces":[{"frames":[{"symbol":"littlemem_st_003","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":73,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":372,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [2]).","traces":[{"frames":[{"symbol":"littlemem_st_003","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":73,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":372,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"littlemem_st_003","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":73,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":372,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","traces":[{"frames":[{"symbol":"littlemem_st_004","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":91,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":377,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Type of lvalue (struct <anonymous>) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_004","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":92,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":377,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_004","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":92,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":377,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"littlemem_st_004","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":92,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":377,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Type of lvalue (struct <anonymous>) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_005","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":117,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":382,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_005","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":117,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":382,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"littlemem_st_005","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":117,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":382,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Type of lvalue (struct <anonymous>) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_006_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":144,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_006","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":151,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":387,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_006_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":144,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_006","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":151,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":387,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"littlemem_st_006_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":144,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_006","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":151,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":387,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Type of lvalue (struct <anonymous>) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_007_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":185,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_007","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":193,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":392,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_007_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":185,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_007","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":193,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":392,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"littlemem_st_007_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":185,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_007","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":193,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":392,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Type of lvalue (struct <anonymous>) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_008_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":228,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_008","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":237,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":397,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_008_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":228,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_008","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":237,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":397,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"littlemem_st_008_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":228,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_008","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":237,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":397,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Type of lvalue (struct <anonymous>) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_009_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":272,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_009","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":281,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":402,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_009_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":272,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_009","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":281,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":402,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"littlemem_st_009_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":272,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_009","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":281,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":402,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Type of lvalue (struct <anonymous>) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_010_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":307,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_010","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":313,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":407,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_010_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":307,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_010","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":313,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":407,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"littlemem_st_010_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":307,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_010","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":313,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":407,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Type of lvalue (struct <anonymous>) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_011_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":343,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_011","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":351,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":412,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [10]).","traces":[{"frames":[{"symbol":"littlemem_st_011_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":343,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_011","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":351,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":412,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"littlemem_st_011_func_002","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":343,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_011","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":351,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"littlemem_st_main","loc":{"rel_file":"littlemem_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/littlemem_st.c","line":412,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Destroying a locked mutex.","traces":[{"frames":[{"symbol":"pthread_mutex_destroy","loc":{"rel_file":"lock_never_unlock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/lock_never_unlock.c","line":57,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"lock_never_unlock_001","loc":{"rel_file":"lock_never_unlock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/lock_never_unlock.c","line":57,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"lock_never_unlock_main","loc":{"rel_file":"lock_never_unlock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/lock_never_unlock.c","line":594,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":185,"column":3,"system_header":false},"locks":[],"language":"C"}]},{"description":"Locked here:","frames":[{"symbol":"pthread_mutex_lock","loc":{"rel_file":"lock_never_unlock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/lock_never_unlock.c","line":40,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"lock_never_unlock_001_tsk_001","loc":{"rel_file":"lock_never_unlock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/lock_never_unlock.c","line":40,"column":2,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-PTHREAD2","citations":[{"document":"CERT-C","section":"CON31-C"},{"document":"POSIX 2008","section":"pthread_mutex_destroy"}],"friendly_cat":"Undefined behavior","long_desc":"According to POSIX 2008, it is undefined behavior to call pthread_mutex_destroy on a mutex which is currently locked. In practice this may prevent any threads that are waiting on that mutex from waking correctly, leading to deadlock or other concurrency bugs in the application. The solution is to always unlock any mutexes prior to destroying them.\n"}
{"description":"Attempting to lock a PTHREAD_MUTEX_DEFAULT mutex that is already locked by the current thread.","traces":[{"frames":[{"symbol":"pthread_mutex_lock","loc":{"rel_file":"lock_never_unlock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/lock_never_unlock.c","line":93,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"lock_never_unlock_002_tsk_001","loc":{"rel_file":"lock_never_unlock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/lock_never_unlock.c","line":93,"column":2,"system_header":false},"locks":[],"language":"C"}]},{"description":"Locked here:","frames":[{"symbol":"pthread_mutex_lock","loc":{"rel_file":"lock_never_unlock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/lock_never_unlock.c","line":90,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"lock_never_unlock_002_tsk_001","loc":{"rel_file":"lock_never_unlock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/lock_never_unlock.c","line":90,"column":2,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-PTHREAD4","citations":[{"document":"CERT-C","section":"MSC15-C"},{"document":"POSIX 2008","section":"pthread_mutex_lock"}],"friendly_cat":"Undefined behavior","long_desc":"According to POSIX 2008, it is undefined behavior to lock a mutex initialized with PTHREAD_MUTEX_DEFAULT in a thread in which the mutex is already locked. In practice this can lead to deadlocking the thread and preventing program execution from continuing. The solution when attempting to lock a mutex that may already be locked by the current thread is to either use a PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE mutex, or else call pthread_mutex_trylock in order to avoi undefined behavior if the mutex is already locked by the current thread.\n"}
{"description":"Casting empty value to type other than void.","traces":[{"frames":[{"symbol":"not_return_001_func_001","loc":{"rel_file":"not_return.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/not_return.c","line":20,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"not_return_001","loc":{"rel_file":"not_return.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/not_return.c","line":29,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"not_return_main","loc":{"rel_file":"not_return.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/not_return.c","line":117,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":203,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV5","citations":[{"document":"C11","section":"6.3.2.2","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 23"},{"document":"CERT-C","section":"MSC15-C"},{"document":"CERT-C","section":"MSC37-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"not_return_001","loc":{"rel_file":"not_return.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/not_return.c","line":29,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"not_return_main","loc":{"rel_file":"not_return.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/not_return.c","line":117,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":203,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a null pointer.","traces":[{"frames":[{"symbol":"null_pointer_001","loc":{"rel_file":"null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/null_pointer.c","line":23,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"null_pointer_main","loc":{"rel_file":"null_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/null_pointer.c","line":359,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":209,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER3","citations":[{"document":"C11","section":"6.5.3.2","paragraph":"4"},{"document":"C11","section":"J.2","paragraph":"1 item 43"},{"document":"CERT-C","section":"EXP34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, dereferencing a null pointer is undefined behavior. In practice this generally leads to abnormal program termination, but it can also silently cause incorrect behavior at runtime if the deference operation does not compile into a read or write instruction at that address. This can occur if a null function pointer is dereferenced, because the subsequent lvalue to rvalue conversion makes the two operations cancel into a nop when compiled by many compilers. It can also occur if a struct field is dereferenced on a null struct pointer, an idiom sometimes used by inexperienced C developers to compute the offset of the struct field. However, this in fact computes the address of the struct field as an offset of the null pointer, which makes this idiom dangerous because the null pointer is not guaranteed to be the same as the zero address. Using a null pointer dereference in this fashion thus can lead to buffer overflow vulnerabilities on some platforms because it will not compute the correct offset. Developers in this case are advised to use the offsetof macro. But generally, the solution is to avoid dereferencing a pointer which may be null without first checking whether it is in fact null, and performing error handling.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":21,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":786,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":21,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":786,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":22,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":786,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_002","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":32,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":791,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_002","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":32,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":791,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_002","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":33,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":791,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_003","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":44,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":796,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Reading outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_003","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":44,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":796,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO7","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"},{"document":"CERT-C","section":"STR32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the second worst case of buffer overflow vulnerability: the read that has occurred has read from a completely separate region of memory. In the worst case, this could result in sensitive information such as private keys and passwords being output to the user, which could lead to entire systems being compromised by the attacker. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_003","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":44,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":796,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_004","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":55,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":801,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_004","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":55,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":801,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_004","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":56,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":801,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_005","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":66,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":806,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_005","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":66,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":806,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_005","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":67,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":806,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_006","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":77,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":811,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_006","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":77,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":811,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_006","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":78,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":811,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_007","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":88,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":816,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_007","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":88,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":816,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_007","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":89,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":816,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_008","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":99,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":821,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"overrun_st_008","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":99,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":821,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_008","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":99,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":821,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_008","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":100,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":821,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_009","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":110,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":826,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"overrun_st_009","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":110,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":826,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_009","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":110,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":826,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_009","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":111,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":826,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_010","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":126,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":831,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_010","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":126,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":831,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_011","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":142,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":836,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_011","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":142,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":836,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_012","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":158,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":841,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_013","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":169,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":846,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_013","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":169,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":846,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_013","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":170,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":846,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_014","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":182,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":851,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"overrun_st_014","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":182,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":851,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_014","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":182,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":851,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_014","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":182,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":851,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_014","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":183,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":851,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_015","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":194,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":856,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_015","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":194,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":856,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_015","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":195,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":856,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_016","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":206,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":861,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_016","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":206,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":861,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_016","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":207,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":861,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_017","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":222,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":866,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_017","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":222,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":866,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_017","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":223,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":866,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_018_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":233,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_018","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":238,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":871,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_018_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":233,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_018","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":238,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":871,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_019","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":250,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":876,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_019","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":250,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":876,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_019","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":251,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":876,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_020","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":264,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":881,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_020","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":264,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":881,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_020","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":265,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":881,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_021","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":280,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":886,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_021","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":280,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":886,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_021","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":281,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":886,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_022","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":293,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":891,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_022","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":293,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":891,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_022","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":294,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":891,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_023","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":306,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":896,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_023","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":306,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":896,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_023","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":307,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":896,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_024","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":320,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":901,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Reading outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_024","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":320,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":901,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO7","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"},{"document":"CERT-C","section":"STR32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the second worst case of buffer overflow vulnerability: the read that has occurred has read from a completely separate region of memory. In the worst case, this could result in sensitive information such as private keys and passwords being output to the user, which could lead to entire systems being compromised by the attacker. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_024","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":320,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":901,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_025","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":333,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":906,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_025","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":333,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":906,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_025","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":334,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":906,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_026","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":346,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":911,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_026","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":346,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":911,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_026","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":347,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":911,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_027","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":359,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":916,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_027","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":359,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":916,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_027","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":360,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":916,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_028","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":372,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":921,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_028","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":372,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":921,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_028","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":373,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":921,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_029","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":387,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":926,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_029","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":387,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":926,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_029","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":388,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":926,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_030","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":402,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":931,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_030","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":402,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":931,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_030","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":403,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":931,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_031","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":415,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":936,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_031","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":415,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":936,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_032","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":428,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":941,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_032","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":428,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":941,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_032","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":429,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":941,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_033","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":443,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":946,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"overrun_st_033","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":443,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":946,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_033","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":443,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":946,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_033","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":443,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":946,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_033","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":444,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":946,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_034","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":457,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":951,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_034","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":457,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":951,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_034","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":458,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":951,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_035","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":471,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":956,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_035","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":471,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":956,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_035","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":472,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":956,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_036","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":489,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":961,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_036","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":489,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":961,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_036","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":490,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":961,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_037_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":502,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_037","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":508,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":966,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_037_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":502,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_037","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":508,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":966,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_037_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":503,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_037","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":508,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":966,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_038","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":522,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":971,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_038","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":522,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":971,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_038","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":523,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":971,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_039","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":538,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":976,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_039","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":538,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":976,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_039","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":539,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":976,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_040","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":556,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":981,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_040","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":556,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":981,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_040","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":557,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":981,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_041","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":570,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":986,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_041","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":570,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":986,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_042","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":588,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":991,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_042","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":588,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":991,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"overrun_st_042","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":588,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":991,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_043","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":613,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":996,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_043","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":613,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":996,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_044","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":630,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1001,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_044","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":630,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1001,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_044","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":631,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1001,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"overrun_st_044","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":631,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1001,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_045_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":642,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_045","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":648,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1006,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_045_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":642,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_045","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":648,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1006,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_045","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":649,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1006,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_046_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":658,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_046","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":664,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1011,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_046_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":658,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_046","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":664,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1011,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_046","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":665,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1011,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_047_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":674,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_047","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":680,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1016,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_047_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":674,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_047","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":680,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1016,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_048_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":689,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_048","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":695,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1021,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_048_func_001","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":689,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_048","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":695,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1021,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"overrun_st_048","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":696,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1021,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_049","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":706,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1026,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_049","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":706,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1026,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_050","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":724,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1031,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"overrun_st_050","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":724,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1031,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_050","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":724,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1031,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_051","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":739,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1036,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_051","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":739,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1036,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_052","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":749,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1041,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_052","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":749,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1041,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Conversion to a pointer type with a stricter alignment requirement (possibly undefined).","traces":[{"frames":[{"symbol":"overrun_st_053","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":760,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1046,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV11","citations":[{"document":"C11","section":"6.3.2.3","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 25"},{"document":"CERT-C","section":"EXP36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if an integer is converted to a pointer and the resulting pointer is not correctly aligned for the resulting type pointed to by the pointer, the behavior is undefined. In general, because layout of objects in memory is unspecified, it is not safe to assume that such a pointer will be well aligned unless the address contained in the integer points to an object whose declared type has an alignment requirement greater than or equal to the alignment requirement of the type pointed to by the pointer. However, the exception is memory allocated dynamically, which can be assumed to have whatever alignment requirement is guaranteed by the C library. Thus, you should always know the alignment requirement of the type of the object being addressed when you perform the conversion, and ensure that it is not possible for the object to have a smaller alignment than the resulting type pointed to by the pointer.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_053","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":761,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1046,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (char [8]).","traces":[{"frames":[{"symbol":"overrun_st_053","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":761,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1046,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_053","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":761,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1046,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_054","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":773,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1051,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"overrun_st_054","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":773,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1051,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"overrun_st_054","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":773,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1051,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"overrun_st_054","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":773,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"overrun_st_main","loc":{"rel_file":"overrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/overrun_st.c","line":1051,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":215,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Floating-point overflow.","traces":[{"frames":[{"symbol":"pow_related_errors_007","loc":{"rel_file":"pow_related_errors.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/pow_related_errors.c","line":164,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"pow_related_errors_main","loc":{"rel_file":"pow_related_errors.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/pow_related_errors.c","line":536,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":227,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV12","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"FLP32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a floating point result can not be represented in the result type, the behavior is undefined. In practice, this error can lead to propagating arithmetic errors throughout any floating-point computation that uses the result of the expression. On systems supporting IEEE 754 arithmetic, the resdult of such an expression is either a positive or negative infinite value, or else SIGFPE is raised. Thus, depending on how the floatingb point exceptions are configured in your application, and depending on your signal handler's behavior, this error can also lead to abnormal program termination. In general, code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n"}
{"description":"Computing pointer difference between two different objects.","traces":[{"frames":[{"symbol":"ptr_subtraction_001","loc":{"rel_file":"ptr_subtraction.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/ptr_subtraction.c","line":22,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"ptr_subtraction_main","loc":{"rel_file":"ptr_subtraction.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/ptr_subtraction.c","line":47,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":233,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA5","citations":[{"document":"C11","section":"6.5.6","paragraph":"9"},{"document":"C11","section":"J.2","paragraph":"1 item 48"},{"document":"CERT-C","section":"ARR36-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if two pointers not part of the same array object are subtracted using the pointer difference operator, the behavior is undefined. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to compute the difference between two different struct fields. If you wish to compute the difference in offsets within the struct, it is recommended that you compute the offsets using the offsetof macro and then perform the subtraction over their integer offsets. In general, the solution is to always be aware of what objects the operands of pointer subtraction come from and never compute pointer difference unless they are known to be from the same array object.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"ptr_subtraction_001","loc":{"rel_file":"ptr_subtraction.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/ptr_subtraction.c","line":23,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"ptr_subtraction_main","loc":{"rel_file":"ptr_subtraction.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/ptr_subtraction.c","line":47,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":233,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"ptr_subtraction_002","loc":{"rel_file":"ptr_subtraction.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/ptr_subtraction.c","line":35,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"ptr_subtraction_main","loc":{"rel_file":"ptr_subtraction.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/ptr_subtraction.c","line":52,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":233,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"ptr_subtraction_002","loc":{"rel_file":"ptr_subtraction.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/ptr_subtraction.c","line":35,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"ptr_subtraction_main","loc":{"rel_file":"ptr_subtraction.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/ptr_subtraction.c","line":52,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":233,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Signed integer overflow.","traces":[{"frames":[{"symbol":"redundant_cond_009","loc":{"rel_file":"redundant_cond.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/redundant_cond.c","line":179,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"redundant_cond_main","loc":{"rel_file":"redundant_cond.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/redundant_cond.c","line":336,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":245,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CCV1","citations":[{"document":"C11","section":"6.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 36"},{"document":"CERT-C","section":"INT32-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the mathematical value of an arithmetic expression producing a signed result can not be represented in the result type, the behavior is undefined. In practice, this error can cause buffer overflow vulnerabilites. Because it is allowed for the minimum value in a signed type to have a greater absolute value than the maximum value, it is also possible for a prefix negation or a division (by -1) to produce an integer overflow. Code must be written in order to ensure that the value of arithmetic expressions cannot overflow based on the range of possible values for the variable and the range of values for the type of the result of the expression.\n\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"return_local_001","loc":{"rel_file":"return_local.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/return_local.c","line":25,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"return_local_main","loc":{"rel_file":"return_local.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/return_local.c","line":55,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":251,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"Dereferencing a null pointer.","traces":[{"frames":[{"symbol":"return_local_001","loc":{"rel_file":"return_local.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/return_local.c","line":26,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"return_local_main","loc":{"rel_file":"return_local.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/return_local.c","line":55,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":251,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER3","citations":[{"document":"C11","section":"6.5.3.2","paragraph":"4"},{"document":"C11","section":"J.2","paragraph":"1 item 43"},{"document":"CERT-C","section":"EXP34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, dereferencing a null pointer is undefined behavior. In practice this generally leads to abnormal program termination, but it can also silently cause incorrect behavior at runtime if the deference operation does not compile into a read or write instruction at that address. This can occur if a null function pointer is dereferenced, because the subsequent lvalue to rvalue conversion makes the two operations cancel into a nop when compiled by many compilers. It can also occur if a struct field is dereferenced on a null struct pointer, an idiom sometimes used by inexperienced C developers to compute the offset of the struct field. However, this in fact computes the address of the struct field as an offset of the null pointer, which makes this idiom dangerous because the null pointer is not guaranteed to be the same as the zero address. Using a null pointer dereference in this fashion thus can lead to buffer overflow vulnerabilities on some platforms because it will not compute the correct offset. Developers in this case are advised to use the offsetof macro. But generally, the solution is to avoid dereferencing a pointer which may be null without first checking whether it is in fact null, and performing error handling.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"sign_conv_001","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":23,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"sign_conv_main","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":275,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":257,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"sign_conv_002","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":35,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"sign_conv_main","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":280,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":257,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"sign_conv_003","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":47,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"sign_conv_main","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":285,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":257,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"sign_conv_004","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":59,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"sign_conv_main","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":290,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":257,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"sign_conv_007","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":96,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"sign_conv_main","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":257,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"sign_conv_008","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":108,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"sign_conv_main","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":310,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":257,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"sign_conv_009","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":124,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"sign_conv_main","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":315,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":257,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"sign_conv_011","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":151,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"sign_conv_main","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":325,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":257,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"sign_conv_013","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":180,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"sign_conv_main","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":335,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":257,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"sign_conv_014","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":192,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"sign_conv_main","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":340,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":257,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"sign_conv_018","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":247,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"sign_conv_main","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":360,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":257,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Conversion to signed integer outside the range that can be represented.","traces":[{"frames":[{"symbol":"sign_conv_019","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":263,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"sign_conv_main","loc":{"rel_file":"sign_conv.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/sign_conv.c","line":365,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":257,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["ImplementationDefined","C"],"error_id":"IMPL-CCV2","citations":[{"document":"C11","section":"6.3.1.3","paragraph":"3"},{"document":"C11","section":"J.3.5","paragraph":"1 item 4"},{"document":"CERT-C","section":"INT31-C"}],"friendly_cat":"Implementation defined behavior","long_desc":"According to ISO C11, it is implementation-defined behavior to convert an integer to a signed integer type which cannot represent the value of the integer. This occurs when a explicit cast or implicit conversion from one type to another (e.g. via an assignment expression or initialization) causes a conversion from one integer type to another. It is distinct from an integer overflow in that an overflow represents an arithmetic expression whose value is not representable in the resulting type, whereas a conversion does not perform an arithmetic operation and merely converts a value from one type to another. In practice, as implementation-defined behavior, the platform is required to document the behavior that occurs in this case. It can either return an implementation defined integer value, or an implementation defined signal can be raised, potentially leading to abnormal program termination. However, which behavior results is determined by the platform. The solution is to either rely on the behavior of the platform, or, if the program should be strictly conforming, to ensure that no conversions take place which require a value to be represented in a type which cannot contain it.\n"}
{"description":"Referring to an object outside of its lifetime.","traces":[{"frames":[{"symbol":"st_cross_thread_access_001_tsk_002","loc":{"rel_file":"st_cross_thread_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/st_cross_thread_access.c","line":63,"column":2,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE4","citations":[{"document":"C11","section":"6.2.4","paragraph":"2"},{"document":"C11","section":"J.2","paragraph":"1 item 9"},{"document":"CERT-C","section":"DCL21-C"},{"document":"CERT-C","section":"DCL30-C"},{"document":"CERT-C","section":"MEM30-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, the value of a pointer after the object pointed to ends its lifetime is indeterminate. In practice this means it is generally a trap representation and therefore reading the value of the pointer is undefined behavior. This includes evaluating the value of a pointer that points to an automatic or thread local variable after it has gone out of scope or the thread has ended respectively, even if another object declared by the same statement and at the same address is currently alive. It also includes reading the value of a pointer variable that points to allocated storage after a call to free has been made. Because the value of the pointer in this case is a trap representation, it is undefined even if the pointer is not dereferenced. The solution if you wish to reference the object is to do it before the lifetime has ended, and the solution if you wish to read the pointer after its value has gone out of scope is to first write the null pointer to the variable.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"st_underrun_001","loc":{"rel_file":"st_underrun.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/st_underrun.c","line":25,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"st_underrun_main","loc":{"rel_file":"st_underrun.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/st_underrun.c","line":265,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":281,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"st_underrun_001","loc":{"rel_file":"st_underrun.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/st_underrun.c","line":25,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"st_underrun_main","loc":{"rel_file":"st_underrun.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/st_underrun.c","line":265,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":281,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"st_underrun_001","loc":{"rel_file":"st_underrun.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/st_underrun.c","line":25,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"st_underrun_main","loc":{"rel_file":"st_underrun.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/st_underrun.c","line":265,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":281,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"st_underrun_001","loc":{"rel_file":"st_underrun.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/st_underrun.c","line":25,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"st_underrun_main","loc":{"rel_file":"st_underrun.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/st_underrun.c","line":265,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":281,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_001","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":21,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":204,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_001","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":21,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":204,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_001","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":21,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":204,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_001","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":21,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":204,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"underrun_st_001","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":21,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":204,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_002","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":31,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":209,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_002","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":31,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":209,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_002","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":31,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":209,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_002","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":31,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":209,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_002","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":31,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":209,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_003","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":42,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":214,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_003","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":42,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":214,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_003","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":42,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":214,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_003","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":42,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":214,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_003","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":42,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":214,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_004","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":55,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":219,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_004","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":55,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":219,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_004","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":55,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":219,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_004","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":55,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":219,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"underrun_st_004","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":55,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":219,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_005","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":67,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":224,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_005","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":67,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":224,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_005","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":67,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":224,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_005","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":67,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":224,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_005","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":67,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":224,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_006","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":80,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":229,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_006","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":80,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":229,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_006","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":80,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":229,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_006","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":80,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":229,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_006","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":80,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":229,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_007","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":93,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":234,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_007","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":93,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":234,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_007","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":93,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":234,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_007","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":93,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":234,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_007","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":93,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":234,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_008","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":110,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":239,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_008","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":110,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":239,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_008","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":109,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":239,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_008","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":109,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":239,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_008","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":109,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":239,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_008","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":109,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":239,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_009","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":124,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":244,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_009","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":124,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":244,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_009","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":124,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":244,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_009","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":124,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":244,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_009","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":124,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":244,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_010","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":141,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":249,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_010","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":141,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":249,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_010","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":140,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":249,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_010","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":140,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":249,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_010","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":140,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":249,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_010","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":140,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":249,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_011","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":155,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":254,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_011","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":155,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":254,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_011","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":155,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":254,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_011","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":155,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":254,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_011","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":155,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":254,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_012","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":259,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_012","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":173,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":259,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_012","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":172,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":259,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_012","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":172,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":259,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_012","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":172,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":259,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_012","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":172,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":259,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"A pointer (or array subscript) outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_013","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":190,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":264,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEA1","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 item 46"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to compute a pointer value which is less than the beginning of an array object, or more than one byte past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer more than one past the end of the field. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that these rules apply regardless of whether the pointer is ever dereferenced; it is the act of constructing such a pointer value itself which is undefined. In general, the solution is to always be aware of the size of the array object which was addressed to create the pointer and avoid constructing pointer values outside the range of allowed addresses.\n"}
{"description":"Found pointer that refers outside the bounds of an object + 1.","traces":[{"frames":[{"symbol":"underrun_st_013","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":190,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":264,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE3","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Dereferencing a pointer past the end of an array.","traces":[{"frames":[{"symbol":"underrun_st_013","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":190,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":264,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER4","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one orf more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. Thus it is undefined behavior to address a struct field, convert to a character pointer, and increment the value of the pointer to one past the end of the field, then dereference it. If you wish to do this, you must first obtain a pointer to the entire struct either by addressing the struct itself, or by converting a pointer to the initial byte of the struct to a pointer to the struct type. Note that this rule in particular applies only to dereferencing the pointer; it is still well-defined to construct a pointer value one past the end of the array as long as that value is not dereferenced. However, constructing a pointer before the beginning of the array object or more than one past the end is still undefined even if no dereferencing occurs. In general, the solution is to always be aware of the size of the arrfay object which was addressed to create the pointer and avoid dereferencing pointer values outside the range of allowed addresses.\n"}
{"description":"Type of lvalue (int) not compatible with the effective type of the object being accessed (int [5]).","traces":[{"frames":[{"symbol":"underrun_st_013","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":190,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":264,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO10","citations":[{"document":"C11","section":"6.5","paragraph":"7"},{"document":"C11","section":"J.2","paragraph":"1 item 37"},{"document":"CERT-C","section":"EXP39-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, most accesses to objects have an effective type. The standard provides certain rules for which types of lvalues are allowed to perform accesses with which effective types. You are encouraged to read up on this in the citations below. If these rules are violated, the compiler's assumptions about which pointers can alias (ie, point to the same object as each other) are violated, which can lead to incorrect and inconsistent program state. The solution is to ensure that all accesses to objects have an effective type compatible with the type of the lvalue performing the access according to the strict aliasing rules defined in the standard. On some compilers, it may also be possible to disable strict aliasing as an optimization, which may be necessary as some memory access patterns are not allowed under strict aliasing.\n"}
{"description":"Trying to write outside the bounds of an object.","traces":[{"frames":[{"symbol":"underrun_st_013","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":190,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"underrun_st_main","loc":{"rel_file":"underrun_st.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/underrun_st.c","line":264,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":287,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EIO2","citations":[{"document":"C11","section":"6.5.6","paragraph":"8"},{"document":"C11","section":"J.2","paragraph":"1 items 47 and 49"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"MEM35-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to dereference a pointer which points before the beginning of an array object, or one or more bytes past the end of it. It is worth noting that the definition of \"array object\" in this case includes both scalars, which are treated in this context identically to an array of length 1, and struct and union fields, which are treated as objects in their own right and therefore identically to an object of the same type which is not a subobject of a struct or union. In this case, the dereferenced memory is outside the bounds of the largest superobject containing the array object that was addressed. This is the worst case type of buffer overflow vulnerability: the write that has occurred has completely overwritten a completely separate region of memory. In the worst case, this could result in user data overwriting the return address of the function, which can lead to code injection attacks which ultimately give the attacker complete control over the machine running this code. This is a critical security vulnerability in your application and should be fixed immediately. The solution is to always track the size of objects and never allow a pointer to be dereferenced outside of the object from which it was created.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_memory_access_001","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":26,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_memory_access_main","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":463,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":293,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"'printf': Mismatch between the type expected by the conversion specifier %d and the type of the argument.","traces":[{"frames":[{"symbol":"printf","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":26,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_memory_access_001","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":26,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_memory_access_main","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":463,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":293,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STDIO1","citations":[{"document":"C11","section":"7.21.6.1","paragraph":"9"},{"document":"C11","section":"J.2","paragraph":"1 item 153"},{"document":"CERT-C","section":"FIO47-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior if an argument passed to a format action for fprintf, printf, etc. is of a type different than that specified by the standard. In practice this can lead to incorrect data printed or even invalid memory accesses, depending on the platform and the implementation of the format functions. Common cases where this constraint is violated include passing a signed value to the %x conversion, or a pointer other than a pointer to void to the %p specifier. However, any type mismatch between the type of the argument and the type specified by the standard constitutes undefined behavior. The solution is to always convert the argument to the necessary type prior to passing it to the function.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_memory_access_002","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":38,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_memory_access_main","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":468,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":293,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_memory_access_003","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":53,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_memory_access_main","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":473,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":293,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Null pointer passed to strcpy.","traces":[{"frames":[{"symbol":"strcpy","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":53,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_memory_access_003","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":53,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_memory_access_main","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":473,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":293,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-STRING1","citations":[{"document":"C11","section":"7.1.4","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 109"},{"document":"CERT-C","section":"ARR30-C"},{"document":"CERT-C","section":"ARR37-C"},{"document":"CERT-C","section":"ARR38-C"},{"document":"CERT-C","section":"EXP34-C"},{"document":"CERT-C","section":"STR31-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if a library function is called with an invalid value for that function, the behavior is undefined. In this case strcpy was called with a null pointer. In practice this will lead to abnormal program termination as memory is accessed at the null pointer address. The solution is to avoid passing null pointers to functions for which they are not explicitly allowed in the standard library, such as strcpy.According to ISO C11, if a library function is called with an invalid value for that function' the behavior is undefined. In this case strcpy was called with a null pointer. In practice this will lead to abnormal program termination as memory is accessed at the null pointer address. The solution is to avoid passing null pointers to functions for which they are not explicitly allowed in the standard library, such as strcpy.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_memory_access_003","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":54,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_memory_access_main","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":473,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":293,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Trying to read through a null pointer.","traces":[{"frames":[{"symbol":"printf","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":54,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_memory_access_003","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":54,"column":9,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_memory_access_main","loc":{"rel_file":"uninit_memory_access.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_memory_access.c","line":473,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":293,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEER1","citations":[{"document":"C11","section":"6.3.2.1","paragraph":"1"},{"document":"C11","section":"J.2","paragraph":"1 item 19"},{"document":"CERT-C","section":"ERR33-C"},{"document":"CERT-C","section":"EXP34-C"}],"friendly_cat":"Undefined behavior","long_desc":""}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_pointer_001","loc":{"rel_file":"uninit_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_pointer.c","line":29,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_pointer_main","loc":{"rel_file":"uninit_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_pointer.c","line":422,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":299,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Dereferencing a null pointer.","traces":[{"frames":[{"symbol":"uninit_pointer_001","loc":{"rel_file":"uninit_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_pointer.c","line":29,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_pointer_main","loc":{"rel_file":"uninit_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_pointer.c","line":422,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":299,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CER3","citations":[{"document":"C11","section":"6.5.3.2","paragraph":"4"},{"document":"C11","section":"J.2","paragraph":"1 item 43"},{"document":"CERT-C","section":"EXP34-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, dereferencing a null pointer is undefined behavior. In practice this generally leads to abnormal program termination, but it can also silently cause incorrect behavior at runtime if the deference operation does not compile into a read or write instruction at that address. This can occur if a null function pointer is dereferenced, because the subsequent lvalue to rvalue conversion makes the two operations cancel into a nop when compiled by many compilers. It can also occur if a struct field is dereferenced on a null struct pointer, an idiom sometimes used by inexperienced C developers to compute the offset of the struct field. However, this in fact computes the address of the struct field as an offset of the null pointer, which makes this idiom dangerous because the null pointer is not guaranteed to be the same as the zero address. Using a null pointer dereference in this fashion thus can lead to buffer overflow vulnerabilities on some platforms because it will not compute the correct offset. Developers in this case are advised to use the offsetof macro. But generally, the solution is to avoid dereferencing a pointer which may be null without first checking whether it is in fact null, and performing error handling.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_001","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":22,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":308,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_002","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":33,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":313,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_003","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":44,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":318,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_004","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":62,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":323,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_005_func_001","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":74,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_005","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":80,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":328,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_006","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":91,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":333,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_007","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":110,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":338,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_008","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":130,"column":6,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":343,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"strcpy","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":141,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_009_func_001","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":141,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_009","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":147,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":348,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_010_func_001","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":160,"column":4,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_010","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":165,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":353,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_011_func_001","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":176,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_011","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":185,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":358,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_012_func_001","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":200,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_012","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":225,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":363,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_013_func_001","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":242,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_013","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":248,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":368,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_014_func_001","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":266,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_014","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":275,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":373,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Indeterminate value used in an expression.","traces":[{"frames":[{"symbol":"uninit_var_015","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":295,"column":5,"system_header":false},"locks":[],"language":"C"},{"symbol":"uninit_var_main","loc":{"rel_file":"uninit_var.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/uninit_var.c","line":378,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":305,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEE2","citations":[{"document":"C11","section":"6.2.4"},{"document":"C11","section":"6.7.9"},{"document":"C11","section":"6.8"},{"document":"C11","section":"J.2","paragraph":"1 item 11"},{"document":"CERT-C","section":"EXP33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, it is undefined behavior to read the value of a variable whose value is indeterminate in many cases. While there are a few exceptions, such as reading the value through an lvalue of character type, or reading the value of an object whose type does not contain trap representations, in general this is considered a very strong antipattern as the value of such bits is completely unspecified and may contain confidential information left over from previous objects at that address whose lifetime has ended. It is recommended that you avoid reading uninitialized memory entirely, in order to avoid safety and security errors arising from the unspecified value. However, in many cases this behavior is undefined and may corrupt the value of memory or registers at which the resulting value is stored. If you don't care about what value is read from some unspecified bytes, but simply want to read some value, it is recommended that the memory first be zeroed to avoid this error.\n"}
{"description":"Attempting to unlock a PTHREAD_MUTEX_DEFAULT or PTHREAD_MUTEX_NORMAL mutex which is not robust and which has not been locked by the current thread.","traces":[{"frames":[{"symbol":"pthread_mutex_unlock","loc":{"rel_file":"unlock_without_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/unlock_without_lock.c","line":43,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"unlock_without_lock_001_tsk_001","loc":{"rel_file":"unlock_without_lock.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/unlock_without_lock.c","line":43,"column":2,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-PTHREAD6","citations":[{"document":"CERT-C","section":"POS48-C"},{"document":"POSIX 2008","section":"pthread_mutex_lock"}],"friendly_cat":"Undefined behavior","long_desc":"According to POSIX 2008, it is undefined behavior to attempt to unlock a PTHREAD_MUTEX_DEFAULT or PTHREAD_MUTEX_NORMAL mutex which was not initialized as robust and which was not already locked by the current thread. In practice this could result in an error being returned, or it could result in corruption of the mutex, leading to incorrect synchronization and concurrency bugs. The solution is to either use a robust mutex, a PTHREAD_MUTEX_ERRORCHECK or PTHREAD_MUTEX_RECURSIVE mutex, or to avoid calling pthread_mutex_unlock unless it is known that the current thread holds the mutex. \n"}
{"description":"Attempt to call the function wrong_arguments_func_pointer_001_func_001 through a pointer with incompatible type.","traces":[{"frames":[{"symbol":"wrong_arguments_func_pointer_001","loc":{"rel_file":"wrong_arguments_func_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/wrong_arguments_func_pointer.c","line":52,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"wrong_arguments_func_pointer_main","loc":{"rel_file":"wrong_arguments_func_pointer.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/wrong_arguments_func_pointer.c","line":611,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":323,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-EFNC1","citations":[{"document":"C11","section":"6.5.2.2","paragraph":"9"},{"document":"C11","section":"J.2","paragraph":"1 items 26 and 41"},{"document":"CERT-C","section":"DCL40-C"},{"document":"CERT-C","section":"EXP37-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, It is undefined behavior to call a function via a function pointer if the type of the function is not compatible with the type of the pointer. This can occur when function pointers are converted to another type, e.g. through a void pointer. In practice this could lead to buffer overflow vulnerabilities and stack corruption because the instructions executed to call the function would be incompatible with the calling convention of the function being called. The solution is to always track the type of function pointers even when converted to another type, and ensure that they are not called via a value of an incompatible type to the function pointed to.\n"}
{"description":"Division by 0.","traces":[{"frames":[{"symbol":"zero_division_001","loc":{"rel_file":"zero_division.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/zero_division.c","line":22,"column":2,"system_header":false},"locks":[],"language":"C"},{"symbol":"zero_division_main","loc":{"rel_file":"zero_division.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/zero_division.c","line":263,"column":3,"system_header":false},"locks":[],"language":"C"},{"symbol":"main","loc":{"rel_file":"main.c","abs_file":"/home/dwightguth/itc-benchmarks/01.w_Defects/main.c","line":329,"column":3,"system_header":false},"locks":[],"language":"C"}]}],"category":["Undefined","C"],"error_id":"UB-CEMX1","citations":[{"document":"C11","section":"6.5.5","paragraph":"5"},{"document":"C11","section":"J.2","paragraph":"1 item 45"},{"document":"CERT-C","section":"INT33-C"}],"friendly_cat":"Undefined behavior","long_desc":"According to ISO C11, if the second operand of a division operation is 0, the behavior is undefined. In practice this generally leads to abnormal program termination, but it can also go into a trap handler or raise a signal instead, depending on the platform. It is also possible on platforms with IEEE 754 floats to silently continue with an infinite or NaN value on floating point division by zero, corrupting future arithmetic data. The solution is that if the second operand can be zero, to check for zero division explicitly and handle it separately.\n"}
