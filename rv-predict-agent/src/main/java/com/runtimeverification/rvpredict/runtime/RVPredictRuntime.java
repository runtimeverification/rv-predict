/*******************************************************************************
 * Copyright (c) 2013 University of Illinois
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/
package com.runtimeverification.rvpredict.runtime;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.Vector;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;

import com.runtimeverification.rvpredict.config.Configuration;
import com.runtimeverification.rvpredict.log.ILoggingEngine;
import com.runtimeverification.rvpredict.metadata.Metadata;
import com.runtimeverification.rvpredict.trace.EventType;
import com.runtimeverification.rvpredict.util.Constants;

/**
 * RV-Predict runtime library that consists of instrumented methods for logging
 * trace events.
 * <p>
 * The instrumented methods are carefully designed to make sure that the logged
 * trace must satisfy the following properties:
 * <ul>
 * <li><b>Program order + Start/Join constraint</b>
 * <p>
 * Therefore, {@link EventType#START} and {@link EventType#PRE_JOIN} must be
 * logged before {@link Thread#start()} and {@link Thread#join()} respectively,
 * while {@link EventType#JOIN}, {@link EventType#JOIN_MAYBE_FAILED} must be
 * logged after {@link Thread#join()}.
 *
 * <li><b>Lock mutual exclusion</b>
 * <p>
 * Lock events must be logged after acquiring the lock, while unlock events must
 * be logged before releasing the lock.
 *
 * <li><b>Interrupt|Interrupted constraint</b>
 * <p>
 * Write on interrupted status generated by {@link Thread#interrupt()} must be
 * logged before the read-then-clear of interrupted status generated by blocking
 * method throwing the {@link InterruptedException}.
 * </ul>
 *
 * <b>Note:</b> we do not, however, guarantee absolute read-write consistency of
 * the logged trace because the running problem could be racey itself. For
 * example, suppose two read and write operations on shared variable {@code x}
 * are racey, the following scenarios are possible:
 *
 *
 *  TODO(YilongL): here is a mistake, read event is logged after the read happens!
 *  reconsider the following examples and conclusion
 * <pre>
 * read-write race:  log(write, x, 1) ~> log(read, x, 0) ~> write(x, 1) ~> read(x, 1), where initValue(x) = 0
 * write-write race: log(write, x, 1) ~> log(write, x, 2) ~> write(x, 2) ~> write(x, 1), where initValue(x) = 0
 * </pre>
 *
 * Even worse, the data race in the program causes our logger to log events that
 * deviate from actual execution.
 * <p>
 * Nevertheless, we do guarantee the soundness of our prediction algorithm
 * <em>at least</em> up till the point that data races in the program mess up
 * the trace because 1) for each trace window, our prediction algorithm doesn't
 * care about the order of events from different threads as we are going to
 * reorder them anyway, and 2) the (incorrectly logged) final values of the
 * racey window <em>might</em> still be a possible outcome that can be inferred
 * from the actual execution.
 *
 * @see EventType
 *
 * @author YilongL
 *
 */
@SuppressWarnings({ "unchecked", "rawtypes" })
public final class RVPredictRuntime implements Constants {

    /**
     * Dummy value used to represent abstract state whose concrete value we do
     * not care about.
     * <p>
     * <b>Note:</b> since we always return 0 as the initial value for all
     * tracked variables, the prediction engine has to understand this dummy
     * value to avoid generating read-write consistency constraint on abstract
     * state.
     */
    private static final long DUMMY_VALUE = Constants._0X_DEADBEEFL;

    private static final String MOCK_STATE_FIELD = "$state";

    public static final Metadata metadata = Metadata.singleton();

    private static int NATIVE_INTERRUPTED_STATUS_VAR_ID = metadata.getVariableId(
            "java.lang.Thread", "$interruptedStatus");
    private static int ATOMIC_BOOLEAN_MOCK_VAL_ID = metadata.getVariableId(
            "java.util.concurrent.atomic.AtomicBoolean", "$value");
    private static int AQS_MOCK_STATE_ID = metadata.getVariableId(
            "java.util.concurrent.locks.AbstractQueuedSynchronizer", MOCK_STATE_FIELD);

    private static final MethodHandle SYNC_COLLECTION_GET_MUTEX = getFieldGetter(
            Collections.synchronizedCollection(Collections.EMPTY_LIST).getClass(), "mutex");
    private static final MethodHandle SYNC_MAP_GET_MUTEX = getFieldGetter(
            Collections.synchronizedMap(Collections.EMPTY_MAP).getClass(), "mutex");

    private static final MethodHandle AQS_GET_STATE = getMethodHandle(AbstractQueuedSynchronizer.class, "getState");
    private static final MethodHandle AQS_SET_STATE = getMethodHandle(AbstractQueuedSynchronizer.class, "setState", int.class);
    private static final MethodHandle AQS_CAS_STATE = getMethodHandle(AbstractQueuedSynchronizer.class, "compareAndSetState", int.class, int.class);

    private static MethodHandle getFieldGetter(Class<?> cls, String name) {
        try {
            Field field = cls.getDeclaredField(name);
            field.setAccessible(true);
            return MethodHandles.lookup().unreflectGetter(field);
        } catch (NoSuchFieldException | SecurityException | IllegalAccessException e) {
            throw new RuntimeException(e);
        }
    }

    private static MethodHandle getMethodHandle(Class<?> cls, String name,
            Class<?>... parameterTypes) {
        try {
            Method method = cls.getDeclaredMethod(name, parameterTypes);
            method.setAccessible(true);
            return MethodHandles.lookup().unreflect(method);
        } catch (NoSuchMethodException | SecurityException | IllegalAccessException e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }
    }

    private static final ConcurrentHashMap<Lock, ReadWriteLock> readLockToRWLock = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<Lock, ReadWriteLock> writeLockToRWLock = new ConcurrentHashMap<>();
    private static final ConcurrentHashMap<Condition, Lock> conditionToLock = new ConcurrentHashMap<>();

    /**
     * Map from iterator to its associated iterable (if any).
     */
    private static final SynchronizedWeakIdentityHashMap<Iterator, Iterable> iteratorToIterable = new SynchronizedWeakIdentityHashMap<>();

    /**
     * Map from view to its backed collection. There are two kinds of view in
     * the Java Collections Framework: the collection views provided in the
     * {@link java.util.Map} interface and the range views provided in the {@link java.util.List},
     * {@link java.util.SortedSet}, and {@link java.util.SortedMap} interfaces.
     */
    private static final SynchronizedWeakIdentityHashMap<Object, Object> viewToBackedCollection = new SynchronizedWeakIdentityHashMap<>();

    private static ILoggingEngine logger;

    private RVPredictRuntime() { } // forbid instantiation

    public static void init(ILoggingEngine logger) {
        RVPredictRuntime.logger = logger;
    }

    public static void logClassInitializerEnter() {
        saveMetaEvent(EventType.CLINIT_ENTER, 0);
    }

    public static void logClassInitializerExit() {
        saveMetaEvent(EventType.CLINIT_EXIT, 0);
    }

    public static void logInvokeMethod(int locId) {
        saveMetaEvent(EventType.INVOKE_METHOD, locId);
    }

    public static void logFinishMethod(int locId) {
        saveMetaEvent(EventType.FINISH_METHOD, locId);
    }

    /**
     * Logs events produced by invoking {@code object.wait()}.
     *
     * @param object
     *            the {@code Object} whose {@code wait()} method is invoked
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictWait(Object object, int locId) throws InterruptedException {
        rvPredictWait(object, 0, locId);
    }

    /**
     * Logs events produced by invoking {@code object.wait(long)}.
     *
     * @param object
     *            the {@code Object} whose {@code wait(long)} method is invoked
     * @param timeout
     *            the first argument of {@code object.wait(long)}
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictWait(Object object, long timeout, int locId)
            throws InterruptedException {
        long monitorId = calcMonitorId(object);
        saveSyncEvent(EventType.WAIT_REL, locId, monitorId);
        try {
            object.wait(timeout);
        } catch (InterruptedException e) {
            onBlockingMethodInterrupted(locId);
            saveSyncEvent(EventType.WAIT_ACQ, locId, monitorId);
            throw e;
        }

        onBlockingMethodNormalReturn(locId);
        saveSyncEvent(EventType.WAIT_ACQ, locId, monitorId);
    }

    /**
     * Logs events produced by invoking {@code object.wait(long, int)}.
     *
     * @param object
     *            the {@code Object} whose {@code wait(long, int)} method is
     *            invoked
     * @param timeout
     *            the first argument of {@code object.wait(long, int)}
     * @param nano
     *            the second argument of {@code object.wait(long, int)}
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictWait(Object object, long timeout, int nano, int locId)
            throws InterruptedException {
        long monitorId = calcMonitorId(object);
        saveSyncEvent(EventType.WAIT_REL, locId, monitorId);
        try {
            object.wait(timeout, nano);
        } catch (InterruptedException e) {
            onBlockingMethodInterrupted(locId);
            saveSyncEvent(EventType.WAIT_ACQ, locId, monitorId);
            throw e;
        }

        onBlockingMethodNormalReturn(locId);
        saveSyncEvent(EventType.WAIT_ACQ, locId, monitorId);
    }

    /**
     * Logs the {@code LOCK} event produced by entering block synchronized with
     * {@code object}'s intrinsic lock.
     *
     * @param object
     *            the {@code Object} whose intrinsic lock is acquired
     * @param locId
     *            the location identifier of the event
     */
    public static void logMonitorEnter(Object object, int locId) {
        saveSyncEvent(EventType.WRITE_LOCK, locId, calcMonitorId(object));
    }

    /**
     * Logs the {@code UNLOCK} event produced by exiting block synchronized with
     * {@code object}'s intrinsic lock.
     *
     * @param object
     *            the {@code Object} whose intrinsic lock is released
     * @param locId
     *            the location identifier of the event
     */
    public static void logMonitorExit(Object object, int locId) {
        saveSyncEvent(EventType.WRITE_UNLOCK, locId, calcMonitorId(object));
    }

    /**
     * Logs the {@code READ/WRITE} event produced by field access.
     *
     * @param object
     *            the owner object of the field; {@code null} when accessing
     *            static fields
     * @param value
     *            the value written by the write access or the value read by the
     *            read access
     * @param variableId
     *            the variable identifier of the field
     * @param isWrite
     *            specifies if it is a write access
     * @param locId
     *            the location identifier of the event
     */
    public static void logFieldAcc(Object object, long value, int variableId, boolean isWrite,
            int locId) {
        saveMemAccEvent(isWrite ? EventType.WRITE : EventType.READ, locId,
                System.identityHashCode(object), -variableId, value);
    }

    /**
     * Logs the {@code READ/WRITE} event produced by array access.
     *
     * @param array
     *            the array to access
     * @param index
     *            the array index
     * @param value
     *            the value written by the write access or the value read by the
     *            read access
     * @param isWrite
     *            specifies if it is a write access
     * @param locId
     *            the location identifier of the event
     */
    public static void logArrayAcc(Object array, int index, long value, boolean isWrite, int locId) {
        saveMemAccEvent(isWrite ? EventType.WRITE : EventType.READ, locId,
                System.identityHashCode(array), index, value);
    }

    /**
     * Logs the {@code START} event produced by invoking {@code thread.start()}.
     *
     * @param thread
     *            the {@code Thread} object whose {@code start()} method is
     *            invoked
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictStart(Thread thread, int locId) {
        saveSyncEvent(EventType.START, locId, thread.getId());
        thread.start();
    }

    /**
     * Logs the {@code JOIN} event produced by invoking {@code thread.join()}.
     *
     * @param thread
     *            the {@code Thread} object whose {@code join()} method is
     *            invoked
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictJoin(Thread thread, int locId) throws InterruptedException {
        rvPredictJoin(thread, 0, locId);
    }

    /**
     * Logs the {@code JOIN} event produced by invoking
     * {@code thread.join(long)}.
     *
     * @param thread
     *            the {@code Thread} object whose {@code join(long)} method is
     *            invoked
     * @param millis
     *            the first argument of {@code thread.join(long)}
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictJoin(Thread thread, long millis, int locId)
            throws InterruptedException {
        try {
            thread.join(millis);
        } catch (InterruptedException e) {
            onBlockingMethodInterrupted(locId);
            throw e;
        }

        onBlockingMethodNormalReturn(locId);
        if (millis == 0) {
            saveSyncEvent(EventType.JOIN, locId, thread.getId());
        }
    }

    /**
     * Logs the {@code JOIN} event produced by invoking
     * {@code thread.join(long, int)}.
     *
     * @param thread
     *            the {@code Thread} object whose {@code join(long, int)} method
     *            is invoked
     * @param millis
     *            the first argument of {@code thread.join(long, int)}
     * @param nanos
     *            the second argument of {@code thread.join(long, int)}
     * @param locId
     *            the location identifier of the event
     *
     */
    public static void rvPredictJoin(Thread thread, long millis, int nanos, int locId)
            throws InterruptedException {
        try {
            thread.join(millis, nanos);
        } catch (InterruptedException e) {
            onBlockingMethodInterrupted(locId);
            throw e;
        }

        onBlockingMethodNormalReturn(locId);
        if (millis == 0 && nanos == 0) {
            saveSyncEvent(EventType.JOIN, locId, thread.getId());
        }
    }

    /**
     * Logs the events produced by invoking {@code Thread#sleep(long)}.
     *
     * @param millis
     *            the first argument of {@code Thread#sleep(long)}
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictSleep(long millis, int locId) throws InterruptedException {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            onBlockingMethodInterrupted(locId);
            throw e;
        }
    }

    /**
     * Logs the events produced by invoking {@code Thread#sleep(long, int)}.
     *
     * @param millis
     *            the first argument of {@code Thread#sleep(long, int)}
     * @param nanos
     *            the second argument of {@code Thread#sleep(long, int)}
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictSleep(long millis, int nanos, int locId)
            throws InterruptedException {
        try {
            Thread.sleep(millis, nanos);
        } catch (InterruptedException e) {
            onBlockingMethodInterrupted(locId);
            throw e;
        }
    }

    /**
     * Logs the events produced by invoking {@code thread.interrupt()}.
     *
     * @param thread
     *            the {@code Thread} object whose {@code interrupt()} method is
     *            invoked
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictInterrupt(Thread thread, int locId) {
        try {
            if (thread != Thread.currentThread()) {
                thread.checkAccess();
            }

            /* TODO(YilongL): Interrupting a thread that is not alive need not
             * have any effect; yet I am not sure how to model such case
             * precisely so I just assume interrupted status will be set to true
             */

            /*
             * make sure the write on interrupted status is logged before the
             * read-and-clear events generated by the blocking method
             */
            saveMemAccEvent(EventType.WRITE, locId, System.identityHashCode(thread),
                    -NATIVE_INTERRUPTED_STATUS_VAR_ID, 1);
            thread.interrupt();
        } catch (SecurityException e) {
            throw e;
        }
    }

    /**
     * Logs the events produced by invoking {@code thread.isInterrupted()}.
     *
     * @param thread
     *            the {@code Thread} object whose {@code isInterrupted()} method
     *            is invoked
     * @param locId
     *            the location identifier of the event
     */
    public static boolean rvPredictIsInterrupted(Thread thread, int locId) {
        boolean isInterrupted = thread.isInterrupted();
        /*
         * the interrupted status is like an imaginary shared variable so we
         * need to record access to it to preserve soundness
         */
        saveMemAccEvent(EventType.READ, locId, System.identityHashCode(thread),
                -NATIVE_INTERRUPTED_STATUS_VAR_ID, bool2int(isInterrupted));
        return isInterrupted;
    }

    /**
     * Logs the events produced by invoking {@code Thread#interrupted()}.
     *
     * @param locId
     *            the location identifier of the event
     */
    public static boolean rvPredictInterrupted(int locId) {
        boolean interrupted = Thread.interrupted();
        saveMemAccEvent(EventType.READ, locId, 0, -NATIVE_INTERRUPTED_STATUS_VAR_ID, interrupted ? 1
                : 0);
        /* clear interrupted status */
        saveMemAccEvent(EventType.WRITE, locId, System.identityHashCode(Thread.currentThread()),
                -NATIVE_INTERRUPTED_STATUS_VAR_ID, 0);
        return interrupted;
    }

    /**
     * Logs the {@code LOCK} event produced by invoking {@code Lock#lock()}.
     *
     * @param lock
     *            the lock to acquire
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictLock(Lock lock, int locId) {
        lock.lock();
        saveSyncEvent(getLockEventType(lock), locId, calcLockId(lock));
    }

    /**
     * Logs events produced by invoking {@code Lock#lockInterruptibly()}.
     *
     * @param lock
     *            the lock to acquire
     * @param locId
     *            the location identifier of the event
     *
     * @throws InterruptedException
     *             see {@link Lock#lockInterruptibly()}
     */
    public static void rvPredictLockInterruptibly(Lock lock, int locId) throws InterruptedException {
        try {
            lock.lockInterruptibly();
            onBlockingMethodNormalReturn(locId);
            saveSyncEvent(getLockEventType(lock), locId, calcLockId(lock));
        } catch (InterruptedException e) {
            onBlockingMethodInterrupted(locId);
            throw e;
        }
    }

    /**
     * Logs the {@code LOCK} event produced by invoking {@code Lock#tryLock()}.
     *
     * @param lock
     *            the lock to acquire
     * @param locId
     *            the location identifier of the event
     */
    public static boolean rvPredictTryLock(Lock lock, int locId) {
        boolean acquired = lock.tryLock();
        if (acquired) {
            saveSyncEvent(getLockEventType(lock), locId, calcLockId(lock));
        }
        return acquired;
    }

    /**
     * Logs events produced by invoking {@code Lock#tryLock(long, TimeUnit)}.
     *
     * @param lock
     *            the lock to acquire
     * @param time
     *            first argument of {@code Lock#tryLock(long, TimeUnit)}
     * @param unit
     *            second argument of {@code Lock#tryLock(long, TimeUnit)}.
     * @param locId
     *            the location identifier of the event
     *
     * @throws InterruptedException
     *             see {@link Lock#tryLock(long, TimeUnit)}
     */
    public static boolean rvPredictTryLock(Lock lock, long time, TimeUnit unit, int locId)
            throws InterruptedException {
        try {
            boolean acquired = lock.tryLock(time, unit);
            if (acquired) {
                onBlockingMethodNormalReturn(locId);
                saveSyncEvent(EventType.WRITE_LOCK, locId, calcLockId(lock));
            }
            return acquired;
        } catch (InterruptedException e) {
            onBlockingMethodInterrupted(locId);
            throw e;
        }
    }

    /**
     * Logs the {@code UNLOCK} event produced by invoking {@code Lock#Unlock()}.
     *
     * @param lock
     *            the lock to release
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictUnlock(Lock lock, int locId) {
        saveSyncEvent(getUnlockEventType(lock), locId, calcLockId(lock));
        lock.unlock();
    }

    /**
     * {@link Lock#newCondition()}
     */
    public static Condition rvPredictLockNewCondition(Lock lock, int locId) {
        Condition condition = lock.newCondition();
        conditionToLock.putIfAbsent(condition, lock);
        return condition;
    }

    /**
     * {@link ReadWriteLock#readLock()}
     */
    public static Lock rvPredictReadWriteLockReadLock(ReadWriteLock readWriteLock, int locId) {
        Lock readLock = readWriteLock.readLock();
        readLockToRWLock.putIfAbsent(readLock, readWriteLock);
        return readLock;
    }

    /**
     * {@link ReadWriteLock#writeLock()}
     */
    public static Lock rvPredictReadWriteLockWriteLock(ReadWriteLock readWriteLock, int locId) {
        Lock writeLock = readWriteLock.writeLock();
        writeLockToRWLock.putIfAbsent(writeLock, readWriteLock);
        return writeLock;
    }

    /**
     * {@link Condition#await()}
     */
    public static void rvPredictConditionAwait(Condition condition, int locId)
            throws InterruptedException {
        long lockId = System.identityHashCode(conditionToLock.get(condition));
        saveSyncEvent(EventType.WAIT_REL, locId, lockId);
        try {
            condition.await();
        } catch (InterruptedException e) {
            onBlockingMethodInterrupted(locId);
            saveSyncEvent(EventType.WAIT_ACQ, locId, lockId);
            throw e;
        }

        onBlockingMethodNormalReturn(locId);
        saveSyncEvent(EventType.WAIT_ACQ, locId, lockId);
    }

    /**
     * {@link Condition#await(long, TimeUnit)}
     */
    public static boolean rvPredictConditionAwait(Condition condition, long time, TimeUnit unit,
            int locId) throws InterruptedException {
        boolean result;
        long lockId = System.identityHashCode(conditionToLock.get(condition));
        saveSyncEvent(EventType.WAIT_REL, locId, lockId);
        try {
            result = condition.await(time, unit);
        } catch (InterruptedException e) {
            onBlockingMethodInterrupted(locId);
            saveSyncEvent(EventType.WAIT_ACQ, locId, lockId);
            throw e;
        }

        onBlockingMethodNormalReturn(locId);
        saveSyncEvent(EventType.WAIT_ACQ, locId, lockId);
        return result;
    }

    /**
     * {@link Condition#awaitNanos(long)}
     */
    public static long rvPredictConditionAwaitNanos(Condition condition, long nanosTimeout,
            int locId) throws InterruptedException {
        long result;
        long lockId = System.identityHashCode(conditionToLock.get(condition));
        saveSyncEvent(EventType.WAIT_REL, locId, lockId);
        try {
            result = condition.awaitNanos(nanosTimeout);
        } catch (InterruptedException e) {
            onBlockingMethodInterrupted(locId);
            saveSyncEvent(EventType.WAIT_ACQ, locId, lockId);
            throw e;
        }

        onBlockingMethodNormalReturn(locId);
        saveSyncEvent(EventType.WAIT_ACQ, locId, lockId);
        return result;
    }

    /**
     * {@link Condition#awaitUntil(Date)}
     */
    public static boolean rvPredictConditionAwaitUntil(Condition condition, Date deadline, int locId)
            throws InterruptedException {
        boolean result;
        long lockId = System.identityHashCode(conditionToLock.get(condition));
        saveSyncEvent(EventType.WAIT_REL, locId, lockId);
        try {
            result = condition.awaitUntil(deadline);
        } catch (InterruptedException e) {
            onBlockingMethodInterrupted(locId);
            saveSyncEvent(EventType.WAIT_ACQ, locId, lockId);
            throw e;
        }

        onBlockingMethodNormalReturn(locId);
        saveSyncEvent(EventType.WAIT_ACQ, locId, lockId);
        return result;
    }

    /**
     * {@link Condition#awaitUninterruptibly()}
     */
    public static void rvPredictConditionAwaitUninterruptibly(Condition condition, int locId) {
        long lockId = System.identityHashCode(conditionToLock.get(condition));
        saveSyncEvent(EventType.WAIT_REL, locId, lockId);
        condition.awaitUninterruptibly();
        saveSyncEvent(EventType.WAIT_ACQ, locId, lockId);
    }

    /**
     * {@link AbstractQueuedSynchronizer#getState()}
     */
    public static int rvPredictAbstractQueuedSynchronizerGetState(AbstractQueuedSynchronizer aqs,
            int locId) {
        synchronized (aqs) {
            int result = (int) invokeMethodHandle(AQS_GET_STATE, aqs);
            saveAtomicEvent(EventType.ATOMIC_READ, locId, System.identityHashCode(aqs),
                    -AQS_MOCK_STATE_ID, result, 0);
            return result;
        }
    }

    /**
     * {@link AbstractQueuedSynchronizer#setState(int)}
     */
    public static void rvPredictAbstractQueuedSynchronizerSetState(AbstractQueuedSynchronizer aqs,
            int newState, int locId) {
        synchronized (aqs) {
            saveAtomicEvent(EventType.ATOMIC_WRITE, locId, System.identityHashCode(aqs),
                    -AQS_MOCK_STATE_ID, newState, 0);
            invokeMethodHandle(AQS_SET_STATE, aqs, newState);
        }
    }

    /**
     * {@link AbstractQueuedSynchronizer#compareAndSetState(int, int)}
     */
    public static boolean rvPredictAbstractQueuedSynchronizerCASState(AbstractQueuedSynchronizer aqs,
            int expect, int update, int locId) {
        synchronized (aqs) {
            saveAtomicEvent(EventType.ATOMIC_READ_THEN_WRITE, locId, System.identityHashCode(aqs),
                    -AQS_MOCK_STATE_ID, (int) invokeMethodHandle(AQS_GET_STATE, aqs), update);
            return (boolean) invokeMethodHandle(AQS_CAS_STATE, aqs, expect, update);
        }
    }

    /**
     * {@link AtomicBoolean#get()}
     */
    public static boolean rvPredictAtomicBoolGet(AtomicBoolean atomicBool, int locId) {
        synchronized (atomicBool) {
            boolean result = atomicBool.get();
            saveAtomicEvent(EventType.ATOMIC_READ, locId, System.identityHashCode(atomicBool),
                    -ATOMIC_BOOLEAN_MOCK_VAL_ID, bool2int(result), 0);
            return result;
        }
    }

    /**
     * {@link AtomicBoolean#set(boolean)}
     */
    public static void rvPredictAtomicBoolSet(AtomicBoolean atomicBool, boolean newValue, int locId) {
        synchronized (atomicBool) {
            saveAtomicEvent(EventType.ATOMIC_WRITE, locId, System.identityHashCode(atomicBool),
                    -ATOMIC_BOOLEAN_MOCK_VAL_ID, bool2int(newValue), 0);
            atomicBool.set(newValue);
        }
    }

    /**
     * {@link AtomicBoolean#getAndSet(boolean)}
     */
    public static boolean rvPredictAtomicBoolGAS(AtomicBoolean atomicBool, boolean newValue,
            int locId) {
        synchronized (atomicBool) {
            boolean result = atomicBool.getAndSet(newValue);
            saveAtomicEvent(EventType.ATOMIC_READ_THEN_WRITE, locId,
                    System.identityHashCode(atomicBool), -ATOMIC_BOOLEAN_MOCK_VAL_ID,
                    bool2int(result), bool2int(newValue));
            return result;
        }
    }

    /**
     * {@link AtomicBoolean#compareAndSet(boolean, boolean)}
     */
    public static boolean rvPredictAtomicBoolCAS(AtomicBoolean atomicBool, boolean expect,
            boolean update, int locId) {
        synchronized (atomicBool) {
            boolean result = atomicBool.compareAndSet(expect, update);
            saveAtomicEvent(EventType.ATOMIC_READ_THEN_WRITE, locId,
                    System.identityHashCode(atomicBool), -ATOMIC_BOOLEAN_MOCK_VAL_ID,
                    result ? bool2int(expect) : bool2int(!expect), bool2int(update));
            return result;
        }
    }

    /**
     * Logs the events produced by invoking
     * {@code System#arraycopy(Object, int, Object, int, int)}.
     *
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictSystemArraycopy(Object src, int srcPos, Object dest, int destPos,
            int length, int locId) {
        // 8 primitive types: boolean, byte, char, short, int, long, float, and
        // double

        if (srcPos >= 0 && destPos >= 0 && length > 0) {
            if (src instanceof Object[]) {
                if (dest instanceof Object[]) {
                    if (srcPos + length <= ((Object[]) src).length
                            && destPos + length <= ((Object[]) dest).length) {
                        int k = length;
                        for (int i = 0; i < length; i++) {
                            Object srcObj = ((Object[]) src)[i + srcPos];
                            if (srcObj == null
                                    || dest.getClass().getComponentType()
                                            .isAssignableFrom(srcObj.getClass())) {
                                logArrayAcc(src, srcPos + i, System.identityHashCode(srcObj),
                                        false, locId);
                            } else {
                                k = i;
                                break;
                            }
                        }
                        for (int i = 0; i < k; i++) {
                            logArrayAcc(dest, destPos + i, System.identityHashCode(((Object[]) src)[i + srcPos]),
                                    true, locId);
                        }
                    }
                }
            } else if (src instanceof boolean[]) {
                if (dest instanceof boolean[]) {
                    if (srcPos + length <= ((boolean[]) src).length
                            && destPos + length <= ((boolean[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, bool2int(((boolean[]) src)[i]), false, locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, ((boolean[]) src)[i - destPos + srcPos] ? 1
                                                            : 0, true, locId);
                        }
                    }
                }
            } else if (src instanceof byte[]) {
                if (dest instanceof byte[]) {
                    if (srcPos + length <= ((byte[]) src).length
                            && destPos + length <= ((byte[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, ((byte[]) src)[i], false, locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, ((byte[]) src)[i - destPos + srcPos], true, locId);
                        }
                    }
                }
            } else if (src instanceof char[]) {
                if (dest instanceof char[]) {
                    if (srcPos + length <= ((char[]) src).length
                            && destPos + length <= ((char[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, ((char[]) src)[i], false, locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, ((char[]) src)[i - destPos + srcPos], true, locId);
                        }
                    }
                }
            } else if (src instanceof short[]) {
                if (dest instanceof short[]) {
                    if (srcPos + length <= ((short[]) src).length
                            && destPos + length <= ((short[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, ((short[]) src)[i], false, locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, ((short[]) src)[i - destPos + srcPos], true, locId);
                        }
                    }
                }
            } else if (dest instanceof int[]) {
                if (srcPos + length <= ((int[]) src).length
                        && destPos + length <= ((int[]) dest).length) {
                    for (int i = srcPos; i < srcPos + length; i++) {
                        logArrayAcc(src, i, ((int[]) src)[i], false, locId);
                    }
                    for (int i = destPos; i < destPos + length; i++) {
                        logArrayAcc(dest, i, ((int[]) src)[i - destPos + srcPos], true, locId);
                    }
                }
            } else if (src instanceof long[]) {
                if (dest instanceof long[]) {
                    if (srcPos + length <= ((long[]) src).length
                            && destPos + length <= ((long[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, ((long[]) src)[i], false, locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, ((long[]) src)[i - destPos + srcPos], true, locId);
                        }
                    }
                }
            } else if (src instanceof float[]) {
                if (dest instanceof float[]) {
                    if (srcPos + length <= ((float[]) src).length
                            && destPos + length <= ((float[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, Float.floatToIntBits(((float[]) src)[i]), false,
                                    locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, Float.floatToIntBits(((float[]) src)[i - destPos + srcPos]),
                                    true,
                                    locId);
                        }
                    }
                }
            } else if (src instanceof double[]) {
                if (dest instanceof double[]) {
                    if (srcPos + length <= ((double[]) src).length
                            && destPos + length <= ((double[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, Double.doubleToLongBits(((double[]) src)[i]), false,
                                    locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, Double.doubleToLongBits(((double[]) src)[i - destPos + srcPos]),
                                    true,
                                    locId);
                        }
                    }
                }
            }
        }

        System.arraycopy(src, srcPos, dest, destPos, length);
    }

    /**
     * {@link Iterable#iterator()}
     */
    public static Iterator rvPredictIterableGetIterator(Iterable iterable, int locId) {
        Iterator iterator = iterable.iterator();
        Iterable value = iteratorToIterable.put(iterator, iterable);
        if (value != null && Configuration.verbose) {
            System.err.println("[Runtime] error: iterator " + iterator
                    + " was already bound to " + value);
        }
        return iterator;
    }

    /**
     * {@link Iterator#hasNext()}
     */
    public static boolean rvPredictIteratorHasNext(Iterator iterator, int locId) {
        boolean result = iterator.hasNext();
        readUsingIterator(iterator, locId);
        return result;
    }

    /**
     * {@link Iterator#next()}
     */
    public static Object rvPredictIteratorNext(Iterator iterator, int locId) {
        Object result = iterator.next();
        readUsingIterator(iterator, locId);
        return result;
    }

    /**
     * {@link Iterator#remove()}
     */
    public static void rvPredictIteratorRemove(Iterator iterator, int locId) {
        writeUsingIterator(iterator, locId);
        iterator.remove();
    }

    /**
     * {@link Collection#add(Object)}
     */
    public static boolean rvPredictCollectionAdd(Collection collection, Object e, int locId) {
        mockCollectionWriteAccess(collection, locId);
        return collection.add(e);
    }

    /**
     * {@link Collection#addAll(Collection)}
     */
    public static boolean rvPredictCollectionAddAll(Collection collection, Collection c, int locId) {
        mockCollectionWriteAccess(collection, locId);
        return collection.addAll(c);
    }

    /**
     * {@link Collection#remove(Object)}
     */
    public static boolean rvPredictCollectionRemove(Collection collection, Object e, int locId) {
        mockCollectionWriteAccess(collection, locId);
        return collection.remove(e);
    }

    /**
     * {@link Collection#removeAll(Collection)}
     */
    public static boolean rvPredictCollectionRemoveAll(Collection collection, Collection c, int locId) {
        mockCollectionWriteAccess(collection, locId);
        return collection.removeAll(c);
    }

    /**
     * {@link Collection#retainAll(Collection)}
     */
    public static boolean rvPredictCollectionRetainAll(Collection collection, Collection c, int locId) {
        mockCollectionWriteAccess(collection, locId);
        return collection.retainAll(c);
    }

    /**
     * {@link Collection#contains(Object)}
     */
    public static boolean rvPredictCollectionContains(Collection collection, Object e, int locId) {
        boolean result = collection.contains(e);
        mockCollectionReadAccess(collection, locId);
        return result;
    }

    /**
     * {@link Collection#containsAll(Collection)}
     */
    public static boolean rvPredictCollectionContainsAll(Collection collection, Collection c, int locId) {
        boolean result = collection.containsAll(c);
        mockCollectionReadAccess(collection, locId);
        return result;
    }

    /**
     * {@link java.util.Collection#clear()}
     */
    public static void rvPredictCollectionClear(Collection collection, int locId) {
        mockCollectionWriteAccess(collection, locId);
        collection.clear();
    }

    /**
     * {@link Collection#toArray()}
     */
    public static Object[] rvPredictCollectionToArray(Collection collection, int locId) {
        Object[] result = collection.toArray();
        mockCollectionReadAccess(collection, locId);
        return result;
    }

    /**
     * {@link Collection#toArray(Object[])}
     */
    public static Object[] rvPredictCollectionToArray(Collection collection, Object[] a, int locId) {
        Object[] result = collection.toArray(a);
        mockCollectionReadAccess(collection, locId);
        return result;
    }

    /**
     * {@link Map#get(Object)}
     */
    public static Object rvPredictMapGet(Map map, Object key, int locId) {
        Object result = map.get(key);
        mockCollectionReadAccess(map, locId);
        return result;
    }

    /**
     * {@link Map#put(Object, Object)}
     */
    public static Object rvPredictMapPut(Map map, Object key, Object value, int locId) {
        mockCollectionWriteAccess(map, locId);
        return map.put(key, value);
    }

    /**
     * {@link Map#putAll(Map)}
     */
    public static void rvPredictMapPutAll(Map map, Map m, int locId) {
        mockCollectionWriteAccess(map, locId);
        map.putAll(m);
    }

    /**
     * {@link Map#remove(Object)}
     */
    public static Object rvPredictMapRemove(Map map, Object key, int locId) {
        mockCollectionWriteAccess(map, locId);
        return map.remove(key);
    }

    /**
     * {@link Map#containsKey(Object)}
     */
    public static boolean rvPredictMapContainsKey(Map map, Object key, int locId) {
        boolean result = map.containsKey(key);
        mockCollectionReadAccess(map, locId);
        return result;
    }

    /**
     * {@link Map#containsValue(Object)}
     */
    public static boolean rvPredictMapContainsValue(Map map, Object value, int locId) {
        boolean result = map.containsValue(value);
        mockCollectionReadAccess(map, locId);
        return result;
    }

    /**
     * {@link Map#clear()}
     */
    public static void rvPredictMapClear(Map map, int locId) {
        mockCollectionWriteAccess(map, locId);
        map.clear();
    }

    /**
     * {@link Map#entrySet()}
     */
    public static Set rvPredictMapEntrySet(Map map, int locId) {
        Set result = map.entrySet();
        viewToBackedCollection.put(result, map);
        return result;
    }

    /**
     * {@link Map#keySet()}
     */
    public static Set rvPredictMapKeySet(Map map, int locId) {
        Set result = map.keySet();
        viewToBackedCollection.put(result, map);
        return result;
    }

    /**
     * {@link Map#values()}
     */
    public static Collection rvPredictMapValues(Map map, int locId) {
        Collection result = map.values();
        viewToBackedCollection.put(result, map);
        return result;
    }

    /**
     * {@link Collections#synchronizedCollection(Collection)}
     */
    public static Collection rvPredictSynchronizedCollection(Collection collection, int locId) {
        Collection syncCollection = Collections.synchronizedCollection(collection);
        viewToBackedCollection.put(syncCollection, collection);
        return syncCollection;
    }

    /**
     * {@link Collections#synchronizedMap(Map)}
     */
    public static Map rvPredictSynchronizedMap(Map map, int locId) {
        Map syncMap = Collections.synchronizedMap(map);
        viewToBackedCollection.put(syncMap, map);
        return syncMap;
    }

    /**
     * Shorthand for {@link MethodHandle#invoke(Object...)}.
     */
    private static Object invokeMethodHandle(MethodHandle mh, Object... objects) {
        try {
            return mh.invokeWithArguments(objects);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    private static int bool2int(boolean b) {
        return b ? 1 : 0;
    }

    private static long calcMonitorId(Object obj) {
        // Use low 32bit for object hash and high 32bit for the magic constant.
        return ((long)MONITOR_C << 32L) + System.identityHashCode(obj);
    }

    private static long calcLockId(Lock lock) {
        if (readLockToRWLock.containsKey(lock)) {
            /* get the associated ReadWriteLock for read lock */
            return System.identityHashCode(readLockToRWLock.get(lock));
        } else if (writeLockToRWLock.containsKey(lock)) {
            /* get the associated ReadWriteLock for write lock */
            return System.identityHashCode(writeLockToRWLock.get(lock));
        } else {
            /* normal lock */
            return System.identityHashCode(lock);
        }
    }

    private static EventType getLockEventType(Lock lock) {
        return readLockToRWLock.containsKey(lock) ? EventType.READ_LOCK : EventType.WRITE_LOCK;
    }

    private static EventType getUnlockEventType(Lock lock) {
        return readLockToRWLock.containsKey(lock) ? EventType.READ_UNLOCK : EventType.WRITE_UNLOCK;
    }

    private static void mockCollectionReadAccess(Object collection, int locId) {
        mockCollectionAccess(collection, false, locId);
    }

    private static void mockCollectionWriteAccess(Object collection, int locId) {
        mockCollectionAccess(collection, true, locId);
    }

    /**
     * Logs event generated by accessing the (abstract) state of a collection
     * object.
     *
     * @param collection
     *            the collection
     * @param locId
     *            the location identifier
     */
    public static void mockCollectionAccess(Object collection, boolean isWrite, int locId) {
        String className = collection.getClass().getName();
        if (collection instanceof Vector || collection instanceof Hashtable
                || className.startsWith("java.util.concurrent.")) {
            /* non-wrapper thread-safe collections */
            return;
        } else if (className.startsWith("java.util.Collections$Synchronized")) {
            /* thread-safe collection wrapper */
            Object mutex;
            mutex = collection instanceof Collection ?
                invokeMethodHandle(SYNC_COLLECTION_GET_MUTEX, collection) :
                invokeMethodHandle(SYNC_MAP_GET_MUTEX, collection);

            Object backedColl = getBackedCollection(collection);
            synchronized (mutex) {
                saveSyncEvent(EventType.WRITE_LOCK, locId, calcMonitorId(mutex));
                saveMemAccEvent(isWrite ? EventType.WRITE : EventType.READ, locId,
                        System.identityHashCode(backedColl),
                        -metadata.getVariableId(backedColl.getClass().getName(), MOCK_STATE_FIELD),
                        DUMMY_VALUE);
                saveSyncEvent(EventType.WRITE_UNLOCK, locId, calcMonitorId(mutex));
            }
        } else {
            /* thread-unsafe collection */
            Object backedColl = getBackedCollection(collection);
            saveMemAccEvent(isWrite ? EventType.WRITE : EventType.READ, locId,
                    System.identityHashCode(backedColl),
                    -metadata.getVariableId(backedColl.getClass().getName(), MOCK_STATE_FIELD),
                    DUMMY_VALUE);
        }
    }

    /**
     * Logs write event generated by accessing some collection (e.g.
     * {@link Collection}, {@link Map}, etc.) using an {@link Iterator}.
     */
    private static void writeUsingIterator(Iterator iterator, int locId) {
        Object collection = resolveAccessedCollection(iterator);
        if (collection != null) {
            mockCollectionWriteAccess(collection, locId);
        }
    }

    /**
     * Logs read event generated by accessing some collection (e.g.
     * {@link Collection}, {@link Map}, etc.) using an {@link Iterator}.
     */
    private static void readUsingIterator(Iterator iterator, int locId) {
        Object collection = resolveAccessedCollection(iterator);
        if (collection != null) {
            mockCollectionReadAccess(collection, locId);
        }
    }

    /**
     * Returns the {@link Collection} or {@link Map} that a given
     * {@link Iterator} is accessing or {@code null} if the accessed collection
     * is not available.
     */
    private static Object resolveAccessedCollection(Iterator iterator) {
        Iterable iterable = iteratorToIterable.get(iterator);
        if (iterable == null) {
            if (Configuration.verbose) {
                /* this is possible because not all iterators are created by
                 * Iterable.iterator() */
                System.err.println("[Runtime] Unable to find the collection associated with " + iterator);
            }
            return null;
        } else {
            return getBackedCollection(iterable);
        }
    }

    /**
     * Gets the backing {@link Collection} or {@link Map} of a given view.
     */
    private static Object getBackedCollection(Object view) {
        assert view != null;
        Object backedColl;
        while (true) {
            backedColl = viewToBackedCollection.get(view);
            if (backedColl == null) {
                return view;
            } else {
                view = backedColl;
            }
        }
    }

    /**
     * Logs events produced by blocking methods being interrupted. In
     * particular, this means that 1) the interrupted status of the current
     * thread has to be true and 2) the interrupted status must then be cleared.
     *
     * @param locId
     *            the location ID
     */
    private static void onBlockingMethodInterrupted(int locId) {
        Thread crntThread = Thread.currentThread();
        /* require interrupted status to be true at the moment */
        saveMemAccEvent(EventType.READ, locId, System.identityHashCode(crntThread),
                -NATIVE_INTERRUPTED_STATUS_VAR_ID, 1);
        /* clear interrupted status */
        saveMemAccEvent(EventType.WRITE, locId, System.identityHashCode(crntThread),
                -NATIVE_INTERRUPTED_STATUS_VAR_ID, 0);
    }

    private static void onBlockingMethodNormalReturn(int locId) {
        /* YilongL: it's possible that another thread interrupts this thread and
         * logs the write of interrupted status to 1 before this read. Thus, the
         * logged global trace could violate read-write consistency on the
         * imaginary interrupted status field */
        saveMemAccEvent(EventType.READ, locId, System.identityHashCode(Thread.currentThread()),
                -NATIVE_INTERRUPTED_STATUS_VAR_ID, 0);
    }

    private static void saveMemAccEvent(EventType eventType, int locId, int addrl, int addrr,
            long value) {
        logger.log(eventType, locId, addrl, addrr, value, 0);
    }

    private static void saveSyncEvent(EventType eventType, int locId, long syncObj) {
        logger.log(eventType, locId, (int)(syncObj >> 32), (int) syncObj, 0, 0);
    }

    private static void saveMetaEvent(EventType eventType, int locId) {
        logger.log(eventType, locId, 0, 0, 0, 0);
    }

    private static void saveAtomicEvent(EventType eventType, int locId, int addrl, int addrr,
            long value1, long value2) {
        logger.log(eventType, locId, addrl, addrr, value1, value2);
    }

}
