/*******************************************************************************
 * Copyright (c) 2013 University of Illinois
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/
package com.runtimeverification.rvpredict.runtime;

import java.lang.invoke.MethodHandle;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;
import java.util.Vector;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.regex.Pattern;

import org.apache.commons.lang3.mutable.MutableInt;

import com.google.common.collect.MapMaker;
import com.runtimeverification.rvpredict.config.Configuration;
import com.runtimeverification.rvpredict.log.EventType;
import com.runtimeverification.rvpredict.log.ILoggingEngine;
import com.runtimeverification.rvpredict.metadata.Metadata;
import com.runtimeverification.rvpredict.util.Constants;

/**
 * RV-Predict runtime library that consists of instrumented methods for logging
 * trace events.
 * <p>
 * The instrumented methods are carefully designed to make sure that the logged
 * trace must satisfy the following properties:
 * <ul>
 * <li><b>Program order + Start/Join constraint</b>
 * <p>
 * Therefore, {@link EventType#START_THREAD} and {@link EventType#PRE_JOIN} must be
 * logged before {@link Thread#start()} and {@link Thread#join()} respectively,
 * while {@link EventType#JOIN_THREAD}, {@link EventType#JOIN_MAYBE_FAILED} must be
 * logged after {@link Thread#join()}.
 *
 * <li><b>Lock mutual exclusion</b>
 * <p>
 * Lock events must be logged after acquiring the lock, while unlock events must
 * be logged before releasing the lock.
 *
 * <li><b>Interrupt|Interrupted constraint</b>
 * <p>
 * Write on interrupted status generated by {@link Thread#interrupt()} must be
 * logged before the read-then-clear of interrupted status generated by blocking
 * method throwing the {@link InterruptedException}.
 * </ul>
 *
 * <b>Note:</b> we do not, however, guarantee absolute read-write consistency of
 * the logged trace because the running problem could be raceful itself. For
 * example, suppose two read and write operations on shared variable {@code x}
 * are raceful, the following scenarios are possible:
 *
 *
 *  TODO(YilongL): here is a mistake, read event is logged after the read happens!
 *  reconsider the following examples and conclusion
 * <pre>
 * read-write race:  log(write, x, 1) ~> log(read, x, 0) ~> write(x, 1) ~> read(x, 1), where initValue(x) = 0
 * write-write race: log(write, x, 1) ~> log(write, x, 2) ~> write(x, 2) ~> write(x, 1), where initValue(x) = 0
 * </pre>
 *
 * Even worse, the data race in the program causes our logger to log events that
 * deviate from actual execution.
 * <p>
 * Nevertheless, we do guarantee the soundness of our prediction algorithm
 * <em>at least</em> up till the point that data races in the program mess up
 * the trace because 1) for each trace window, our prediction algorithm doesn't
 * care about the order of events from different threads as we are going to
 * reorder them anyway, and 2) the (incorrectly logged) final values of the
 * raceful window <em>might</em> still be a possible outcome that can be inferred
 * from the actual execution.
 *
 * @see EventType
 *
 * @author YilongL
 *
 */
@SuppressWarnings({ "unchecked", "rawtypes" })
public final class RVPredictRuntime implements Constants {

    private static final String MOCK_STATE_FIELD = "$state";

    public static final Metadata metadata = Metadata.singleton();

    /**
     * <em>Interruption rule:</em> A thread calling interrupt on another thread
     * happens before the interrupted thread detects the interrupt (either by
     * having {@code InterruptedException} thrown, or invoking
     * {@link Thread#isInterrupted()} or {@link Thread#interrupted()}).
     */
    private static int THREAD_INTERRUPTED_STATUS_VAR_ID = metadata.getVariableId(
            "java.lang.Thread", "$interruptedStatus");

    private static final MethodHandle SYNC_COLLECTION_GET_MUTEX = Helper.getFieldGetter(
            Collections.synchronizedCollection(Collections.EMPTY_LIST).getClass(), "mutex");
    private static final MethodHandle SYNC_MAP_GET_MUTEX = Helper.getFieldGetter(
            Collections.synchronizedMap(Collections.EMPTY_MAP).getClass(), "mutex");
    private static final MethodHandle THREAD_START0 = Helper.getMethodHandle(Thread.class, "start0");

    /**
     * Map from iterator to its associated iterable (if any).
     */
    private static final ConcurrentMap<Iterator, Iterable> iteratorToIterable = new MapMaker()
            .weakKeys().weakValues().makeMap();

    /**
     * Map from view to its backed collection. There are two kinds of view in
     * the Java Collections Framework: the collection views provided in the
     * {@link java.util.Map} interface and the range views provided in the
     * {@link java.util.List}, {@link java.util.SortedSet}, and
     * {@link java.util.SortedMap} interfaces.
     */
    private static final ConcurrentMap<Object, Object> viewToBackingCollection = new MapMaker()
            .weakKeys().weakValues().makeMap();

    private static final ConcurrentMap<Object, MutableInt> collectionToState = new MapMaker()
            .weakKeys().makeMap();

    private static ILoggingEngine logger;

    private static Configuration config;

    private RVPredictRuntime() { } // forbid instantiation

    public static void init(Configuration config, ILoggingEngine logger) {
        RVPredictRuntime.config = config;
        RVPredictRuntime.logger = logger;
    }

    public static void logClassInitializerEnter() {
        saveMetaEvent(EventType.CLINIT_ENTER, 0);
    }

    public static void logClassInitializerExit() {
        saveMetaEvent(EventType.CLINIT_EXIT, 0);
    }

    public static void logInvokeMethod(int locId) {
        if (config.stacks()) {
            saveMetaEvent(EventType.INVOKE_METHOD, locId);
        }
    }

    public static void logFinishMethod(int locId) {
        if (config.stacks()) {
            saveMetaEvent(EventType.FINISH_METHOD, locId);
        }
    }

    /**
     * Logs events produced by invoking {@code object.wait()}.
     *
     * @param object
     *            the {@code Object} whose {@code wait()} method is invoked
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictWait(Object object, int locId) throws InterruptedException {
        rvPredictWait(object, 0, locId);
    }

    /**
     * Logs events produced by invoking {@code object.wait(long)}.
     *
     * @param object
     *            the {@code Object} whose {@code wait(long)} method is invoked
     * @param timeout
     *            the first argument of {@code object.wait(long)}
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictWait(Object object, long timeout, int locId)
            throws InterruptedException {
        saveLockEvent(EventType.WAIT_RELEASE, locId, MONITOR_C, object);
        try {
            object.wait(timeout);
        } catch (InterruptedException e) {
            clearInterruptedStatus(Thread.currentThread(), locId);
            saveLockEvent(EventType.WAIT_ACQUIRE, locId, MONITOR_C, object);
            throw e;
        }

        saveLockEvent(EventType.WAIT_ACQUIRE, locId, MONITOR_C, object);
    }

    /**
     * Logs events produced by invoking {@code object.wait(long, int)}.
     *
     * @param object
     *            the {@code Object} whose {@code wait(long, int)} method is
     *            invoked
     * @param timeout
     *            the first argument of {@code object.wait(long, int)}
     * @param nano
     *            the second argument of {@code object.wait(long, int)}
     * @param locId
     *            the location identifier of the event
     */
    public static void rvPredictWait(Object object, long timeout, int nano, int locId)
            throws InterruptedException {
        saveLockEvent(EventType.WAIT_RELEASE, locId, MONITOR_C, object);
        try {
            object.wait(timeout, nano);
        } catch (InterruptedException e) {
            clearInterruptedStatus(Thread.currentThread(), locId);
            saveLockEvent(EventType.WAIT_ACQUIRE, locId, MONITOR_C, object);
            throw e;
        }

        saveLockEvent(EventType.WAIT_ACQUIRE, locId, MONITOR_C, object);
    }

    /**
     * Logs the {@code LOCK} event produced by entering block synchronized with
     * {@code object}'s intrinsic lock.
     *
     * @param object
     *            the {@code Object} whose intrinsic lock is acquired
     * @param locId
     *            the location identifier of the event
     */
    public static void logMonitorEnter(Object object, int locId) {
        saveLockEvent(EventType.WRITE_LOCK, locId, MONITOR_C, object);
    }

    /**
     * Logs the {@code UNLOCK} event produced by exiting block synchronized with
     * {@code object}'s intrinsic lock.
     *
     * @param object
     *            the {@code Object} whose intrinsic lock is released
     * @param locId
     *            the location identifier of the event
     */
    public static void logMonitorExit(Object object, int locId) {
        saveLockEvent(EventType.WRITE_UNLOCK, locId, MONITOR_C, object);
    }

    /**
     * Logs the {@code READ/WRITE} event produced by field access.
     *
     * @param object
     *            the owner object of the field, which would be the class
     *            literal when accessing static field
     * @param value
     *            the value written by the write access or the value read by the
     *            read access
     * @param variableId
     *            the variable identifier of the field
     * @param isWrite
     *            specifies if it is a write access
     * @param locId
     *            the location identifier of the event
     */
    public static void logFieldAcc(Object object, long value, int variableId, boolean isWrite,
            int locId) {
        saveMemAccEvent(isWrite ? EventType.WRITE : EventType.READ, locId,
                System.identityHashCode(object), -variableId, value);
    }

    /**
     * Logs the {@code READ/WRITE} event produced by array access.
     *
     * @param array
     *            the array to access
     * @param index
     *            the array index
     * @param value
     *            the value written by the write access or the value read by the
     *            read access
     * @param isWrite
     *            specifies if it is a write access
     * @param locId
     *            the location identifier of the event
     */
    public static void logArrayAcc(Object array, int index, long value, boolean isWrite, int locId) {
        saveMemAccEvent(isWrite ? EventType.WRITE : EventType.READ, locId,
                System.identityHashCode(array), index, value);
    }

    /**
     * {@link Thread#start0()}
     */
    public static void rvPredictStart0(Thread thread, int locId) {
        locId = metadata.getLocationId(new Throwable().getStackTrace()[2].toString());
        saveThreadSyncEvent(EventType.START_THREAD, locId, thread.getId());
        metadata.addOriginalThreadCreationInfo(thread.getId(), Thread.currentThread().getId(), locId);
        try {
            THREAD_START0.invoke(thread);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * {@link Thread#isAlive()}
     * <p>
     * <i>Thread termination rule:</i> Any action in a thread happens before any
     * other thread detects that thread has terminated, either by successfully
     * return from {@link Thread#join()} or by {@link Thread#isAlive()}
     * returning false.
     */
    public static boolean rvPredictIsAlive(Thread thread, int locId) {
        if (!thread.isAlive()) {
            saveThreadSyncEvent(EventType.JOIN_THREAD, locId, thread.getId());
            return false;
        }
        return true;
    }

    /**
     * {@link Thread#join()}
     */
    public static void rvPredictJoin(Thread thread, int locId) throws InterruptedException {
        rvPredictJoin(thread, 0, locId);
    }

    /**
     * {@link Thread#join(long)}
     */
    public static void rvPredictJoin(Thread thread, long millis, int locId)
            throws InterruptedException {
        try {
            thread.join(millis);
        } catch (InterruptedException e) {
            clearInterruptedStatus(Thread.currentThread(), locId);
            throw e;
        }

        if (millis == 0) {
            saveThreadSyncEvent(EventType.JOIN_THREAD, locId, thread.getId());
        }
    }

    /**
     * {@link Thread#join(long, int)}
     */
    public static void rvPredictJoin(Thread thread, long millis, int nanos, int locId)
            throws InterruptedException {
        try {
            thread.join(millis, nanos);
        } catch (InterruptedException e) {
            clearInterruptedStatus(Thread.currentThread(), locId);
            throw e;
        }

        if (millis == 0 && nanos == 0) {
            saveThreadSyncEvent(EventType.JOIN_THREAD, locId, thread.getId());
        }
    }

    /**
     * {@link Thread#sleep(long)}
     */
    public static void rvPredictSleep(long millis, int locId) throws InterruptedException {
        try {
            Thread.sleep(millis);
        } finally {
            clearInterruptedStatus(Thread.currentThread(), locId);
        }
    }

    /**
     * {@link Thread#sleep(long,int)}
     */
    public static void rvPredictSleep(long millis, int nanos, int locId)
            throws InterruptedException {
        try {
            Thread.sleep(millis, nanos);
        } finally {
            clearInterruptedStatus(Thread.currentThread(), locId);
        }
    }

    /**
     * {@link Thread#interrupt()}
     */
    public static void rvPredictInterrupt(Thread thread, int locId) {
        if (thread != Thread.currentThread()) {
            thread.checkAccess();
        }
        setInterruptedStatus(thread, locId);
        thread.interrupt();
    }

    /**
     * {@link Thread#isInterrupted()}
     */
    public static boolean rvPredictIsInterrupted(Thread thread, int locId) {
        boolean result = thread.isInterrupted();
        testInterruptedStatus(thread, result, false /* reset */, locId);
        return result;
    }

    /**
     * {@link Thread#interrupted()}
     */
    public static boolean rvPredictInterrupted(int locId) {
        boolean result = Thread.interrupted();
        testInterruptedStatus(Thread.currentThread(), result, true /* reset */, locId);
        return result;
    }

    private static void setInterruptedStatus(Thread t, int locId) {
        saveAtomicEvent(EventType.ATOMIC_WRITE, locId, System.identityHashCode(t),
                -THREAD_INTERRUPTED_STATUS_VAR_ID, 1, 0);
    }

    private static void clearInterruptedStatus(Thread t, int locId) {
        saveAtomicEvent(EventType.ATOMIC_WRITE, locId, System.identityHashCode(t),
                -THREAD_INTERRUPTED_STATUS_VAR_ID, 0, 0);
    }

    private static void testInterruptedStatus(Thread t, boolean isInterrupted,
            boolean clearInterrupted, int locId) {
        if (clearInterrupted) {
            if (isInterrupted) {
                saveAtomicEvent(EventType.ATOMIC_READ_THEN_WRITE, locId,
                        System.identityHashCode(t), -THREAD_INTERRUPTED_STATUS_VAR_ID, 1, 0);
            } else {
                saveAtomicEvent(EventType.ATOMIC_READ, locId, System.identityHashCode(t),
                        -THREAD_INTERRUPTED_STATUS_VAR_ID, 0, 0);
            }
        } else {
            saveAtomicEvent(EventType.ATOMIC_READ, locId, System.identityHashCode(t),
                    -THREAD_INTERRUPTED_STATUS_VAR_ID, bool2int(isInterrupted), 0);
        }
    }

    /**
     * {@link System#arraycopy(Object,int,Object,int,int)}
     */
    public static void rvPredictSystemArraycopy(Object src, int srcPos, Object dest, int destPos,
            int length, int locId) {
        // 8 primitive types: boolean, byte, char, short, int, long, float, and
        // double

        if (srcPos >= 0 && destPos >= 0 && length > 0) {
            if (src instanceof Object[]) {
                if (dest instanceof Object[]) {
                    if (srcPos + length <= ((Object[]) src).length
                            && destPos + length <= ((Object[]) dest).length) {
                        int k = length;
                        for (int i = 0; i < length; i++) {
                            Object srcObj = ((Object[]) src)[i + srcPos];
                            if (srcObj == null
                                    || dest.getClass().getComponentType()
                                            .isAssignableFrom(srcObj.getClass())) {
                                logArrayAcc(src, srcPos + i, System.identityHashCode(srcObj),
                                        false, locId);
                            } else {
                                k = i;
                                break;
                            }
                        }
                        for (int i = 0; i < k; i++) {
                            logArrayAcc(dest, destPos + i, System.identityHashCode(((Object[]) src)[i + srcPos]),
                                    true, locId);
                        }
                    }
                }
            } else if (src instanceof boolean[]) {
                if (dest instanceof boolean[]) {
                    if (srcPos + length <= ((boolean[]) src).length
                            && destPos + length <= ((boolean[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, bool2int(((boolean[]) src)[i]), false, locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, ((boolean[]) src)[i - destPos + srcPos] ? 1
                                                            : 0, true, locId);
                        }
                    }
                }
            } else if (src instanceof byte[]) {
                if (dest instanceof byte[]) {
                    if (srcPos + length <= ((byte[]) src).length
                            && destPos + length <= ((byte[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, ((byte[]) src)[i], false, locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, ((byte[]) src)[i - destPos + srcPos], true, locId);
                        }
                    }
                }
            } else if (src instanceof char[]) {
                if (dest instanceof char[]) {
                    if (srcPos + length <= ((char[]) src).length
                            && destPos + length <= ((char[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, ((char[]) src)[i], false, locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, ((char[]) src)[i - destPos + srcPos], true, locId);
                        }
                    }
                }
            } else if (src instanceof short[]) {
                if (dest instanceof short[]) {
                    if (srcPos + length <= ((short[]) src).length
                            && destPos + length <= ((short[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, ((short[]) src)[i], false, locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, ((short[]) src)[i - destPos + srcPos], true, locId);
                        }
                    }
                }
            } else if (dest instanceof int[]) {
                if (srcPos + length <= ((int[]) src).length
                        && destPos + length <= ((int[]) dest).length) {
                    for (int i = srcPos; i < srcPos + length; i++) {
                        logArrayAcc(src, i, ((int[]) src)[i], false, locId);
                    }
                    for (int i = destPos; i < destPos + length; i++) {
                        logArrayAcc(dest, i, ((int[]) src)[i - destPos + srcPos], true, locId);
                    }
                }
            } else if (src instanceof long[]) {
                if (dest instanceof long[]) {
                    if (srcPos + length <= ((long[]) src).length
                            && destPos + length <= ((long[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, ((long[]) src)[i], false, locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, ((long[]) src)[i - destPos + srcPos], true, locId);
                        }
                    }
                }
            } else if (src instanceof float[]) {
                if (dest instanceof float[]) {
                    if (srcPos + length <= ((float[]) src).length
                            && destPos + length <= ((float[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, Float.floatToIntBits(((float[]) src)[i]), false,
                                    locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, Float.floatToIntBits(((float[]) src)[i - destPos + srcPos]),
                                    true,
                                    locId);
                        }
                    }
                }
            } else if (src instanceof double[]) {
                if (dest instanceof double[]) {
                    if (srcPos + length <= ((double[]) src).length
                            && destPos + length <= ((double[]) dest).length) {
                        for (int i = srcPos; i < srcPos + length; i++) {
                            logArrayAcc(src, i, Double.doubleToLongBits(((double[]) src)[i]), false,
                                    locId);
                        }
                        for (int i = destPos; i < destPos + length; i++) {
                            logArrayAcc(dest, i, Double.doubleToLongBits(((double[]) src)[i - destPos + srcPos]),
                                    true,
                                    locId);
                        }
                    }
                }
            }
        }

        System.arraycopy(src, srcPos, dest, destPos, length);
    }

    /**
     * {@link Iterable#iterator()}
     */
    public static Iterator rvPredictIterableGetIterator(Iterable iterable, int locId) {
        Iterator iterator = iterable.iterator();
        if (iterator != null) {
            iteratorToIterable.put(iterator, iterable);
        }
        return iterator;
    }

    /**
     * {@link List#listIterator()}
     */
    public static ListIterator rvPredictListGetListIterator(List list, int locId) {
        ListIterator listItr = list.listIterator();
        if (listItr != null) {
            iteratorToIterable.put(listItr, list);
        }
        return listItr;
    }

    /**
     * {@link List#listIterator(int)}
     */
    public static ListIterator rvPredictListGetListIterator(List list, int index, int locId) {
        ListIterator listItr = list.listIterator(index);
        if (listItr != null) {
            iteratorToIterable.put(listItr, list);
        }
        return listItr;
    }

    /**
     * {@link Iterator#hasNext()}
     */
    public static boolean rvPredictIteratorHasNext(Iterator iterator, int locId) {
        return readUsingIterator(iterator, locId, () -> {
            return iterator.hasNext();
        });
    }

    /**
     * {@link Iterator#next()}
     */
    public static Object rvPredictIteratorNext(Iterator iterator, int locId) {
        return readUsingIterator(iterator, locId, () -> {
            return iterator.next();
        });
    }

    /**
     * {@link Iterator#remove()}
     */
    public static void rvPredictIteratorRemove(Iterator iterator, int locId) {
        writeUsingIterator(iterator, locId, () -> {
            iterator.remove();
            return null;
        });
    }

    /**
     * {@link ListIterator#hasPrevious()}
     */
    public static boolean rvPredictListIteratorHasPrevious(ListIterator listItr, int locId) {
        return readUsingIterator(listItr, locId, () -> {
            return listItr.hasPrevious();
        });
    }

    /**
     * {@link ListIterator#previous()}
     */
    public static Object rvPredictListIteratorPrevious(ListIterator listItr, int locId) {
        return readUsingIterator(listItr, locId, () -> {
            return listItr.previous();
        });
    }

    /**
     * {@link ListIterator#add(Object)}
     */
    public static void rvPredictListIteratorAdd(ListIterator listItr, Object e, int locId) {
        writeUsingIterator(listItr, locId, () -> {
            listItr.add(e);
            return null;
        });
    }

    /**
     * {@link ListIterator#set(Object)}
     */
    public static void rvPredictListIteratorSet(ListIterator listItr, Object e, int locId) {
        writeUsingIterator(listItr, locId, () -> {
            listItr.set(e);
            return null;
        });
    }

    /**
     * {@link Collection#size()}
     */
    public static int rvPredictCollectionSize(Collection collection, int locId) {
        return logCollectionReadAccess(collection, locId, () -> {
            return collection.size();
        });
    }

    /**
     * {@link Collection#isEmpty()}
     */
    public static boolean rvPredictCollectionIsEmpty(Collection collection, int locId) {
        return logCollectionReadAccess(collection, locId, () -> {
            return collection.isEmpty();
        });
    }

    /**
     * {@link Collection#add(Object)}
     */
    public static boolean rvPredictCollectionAdd(Collection collection, Object e, int locId) {
        return logCollectionWriteAccess(collection, locId, () -> {
            return collection.add(e);
        });
    }

    /**
     * {@link Collection#addAll(Collection)}
     */
    public static boolean rvPredictCollectionAddAll(Collection collection, Collection c, int locId) {
        return logCollectionWriteAccess(collection, locId, () -> {
            return collection.addAll(c);
        });
    }

    /**
     * {@link Collection#remove(Object)}
     */
    public static boolean rvPredictCollectionRemove(Collection collection, Object e, int locId) {
        return logCollectionWriteAccess(collection, locId, () -> {
            return collection.remove(e);
        });
    }

    /**
     * {@link Collection#removeAll(Collection)}
     */
    public static boolean rvPredictCollectionRemoveAll(Collection collection, Collection c, int locId) {
        return logCollectionWriteAccess(collection, locId, () -> {
            return collection.removeAll(c);
        });
    }

    /**
     * {@link Collection#retainAll(Collection)}
     */
    public static boolean rvPredictCollectionRetainAll(Collection collection, Collection c, int locId) {
        return logCollectionWriteAccess(collection, locId, () -> {
            return collection.retainAll(c);
        });
    }

    /**
     * {@link Collection#contains(Object)}
     */
    public static boolean rvPredictCollectionContains(Collection collection, Object e, int locId) {
        return logCollectionReadAccess(collection, locId, () -> {
            return collection.contains(e);
        });
    }

    /**
     * {@link Collection#containsAll(Collection)}
     */
    public static boolean rvPredictCollectionContainsAll(Collection collection, Collection c, int locId) {
        return logCollectionReadAccess(collection, locId, () -> {
            return collection.containsAll(c);
        });
    }

    /**
     * {@link java.util.Collection#clear()}
     */
    public static void rvPredictCollectionClear(Collection collection, int locId) {
        logCollectionWriteAccess(collection, locId, () -> {
            collection.clear();
            return null;
        });
    }

    /**
     * {@link Collection#toArray()}
     */
    public static Object[] rvPredictCollectionToArray(Collection collection, int locId) {
        return logCollectionReadAccess(collection, locId, () -> {
            return collection.toArray();
        });
    }

    /**
     * {@link Collection#toArray(Object[])}
     */
    public static Object[] rvPredictCollectionToArray(Collection collection, Object[] a, int locId) {
        return logCollectionReadAccess(collection, locId, () -> {
            return collection.toArray(a);
        });
    }

    /**
     * {@link List#get(int)}
     */
    public static Object rvPredictListGet(List list, int index, int locId) {
        return logCollectionReadAccess(list, locId, () -> {
            return list.get(index);
        });
    }

    /**
     * {@link List#set(int, Object)}
     */
    public static Object rvPredictListSet(List list, int index, Object e, int locId) {
        return logCollectionWriteAccess(list, locId, () -> {
            return list.set(index, e);
        });
    }

    /**
     * {@link List#add(int, Object)}
     */
    public static void rvPredictListAdd(List list, int index, Object e, int locId) {
        logCollectionWriteAccess(list, locId, () -> {
            list.add(index, e);
            return null;
        });
    }

    /**
     * {@link List#remove(int)}
     */
    public static Object rvPredictListRemove(List list, int index, int locId) {
        return logCollectionWriteAccess(list, locId, () -> {
            return list.remove(index);
        });
    }

    /**
     * {@link List#indexOf(Object)}
     */
    public static int rvPredictListIndexOf(List list, Object e, int locId) {
        return logCollectionReadAccess(list, locId, () -> {
            return list.indexOf(e);
        });
    }

    /**
     * {@link Map#compute(Object, BiFunction)}
     */
    public static Object rvPredictMapCompute(Map map, Object key, BiFunction remappingFunction,
            int locId) {
        return logCollectionWriteAccess(map, locId, () -> {
            return map.compute(key, remappingFunction);
        });
    }

    /**
     * {@link Map#computeIfAbsent(Object, Function)}
     */
    public static Object rvPredictMapComputeIfAbsent(Map map, Object key, Function mappingFunction,
            int locId) {
        return logCollectionWriteAccess(map, locId, () -> {
            return map.computeIfAbsent(key, mappingFunction);
        });
    }

    /**
     * {@link Map#computeIfPresent(Object, BiFunction)}
     */
    public static Object rvPredictMapComputeIfPresent(Map map, Object key, BiFunction remappingFunction,
            int locId) {
        return logCollectionWriteAccess(map, locId, () -> {
            return map.computeIfPresent(key, remappingFunction);
        });
    }

    /**
     * {@link Map#forEach(BiConsumer)}
     */
    public static void rvPredictMapForEach(Map map, BiConsumer action, int locId) {
        logCollectionReadAccess(map, locId, () -> {
            map.forEach(action);
            return null;
        });
    }

    /**
     * {@link Map#merge(Object, Object, BiFunction)}
     */
    public static Object rvPredictMapMerge(Map map, Object key, Object value,
            BiFunction remappingFunction, int locId) {
        return logCollectionWriteAccess(map, locId, () -> {
            return map.merge(key, value, remappingFunction);
        });
    }

    /**
     * {@link Map#get(Object)}
     */
    public static Object rvPredictMapGet(Map map, Object key, int locId) {
        return logCollectionReadAccess(map, locId, () -> {
            return map.get(key);
        });
    }

    /**
     * {@link Map#getOrDefault(Object, Object)}
     */
    public static Object rvPredictMapGetOrDefault(Map map, Object key, Object defaultVal,
            int locId) {
        return logCollectionReadAccess(map, locId, () -> {
            return map.getOrDefault(key, defaultVal);
        });
    }

    /**
     * {@link Map#put(Object, Object)}
     */
    public static Object rvPredictMapPut(Map map, Object key, Object value, int locId) {
        return logCollectionWriteAccess(map, locId, () -> {
            return map.put(key, value);
        });
    }

    /**
     * {@link Map#putAll(Map)}
     */
    public static void rvPredictMapPutAll(Map map, Map m, int locId) {
        logCollectionWriteAccess(map, locId, () -> {
            map.putAll(m);
            return null;
        });
    }

    /**
     * {@link Map#putIfAbsent(Object, Object)}
     */
    public static Object rvPredictMapPutIfAbsent(Map map, Object key, Object value, int locId) {
        return logCollectionWriteAccess(map, locId, () -> {
            return map.putIfAbsent(key, value);
        });
    }

    /**
     * {@link Map#remove(Object)}
     */
    public static Object rvPredictMapRemove(Map map, Object key, int locId) {
        return logCollectionWriteAccess(map, locId, () -> {
            return map.remove(key);
        });
    }

    /**
     * {@link Map#remove(Object, Object)}
     */
    public static boolean rvPredictMapRemove(Map map, Object key, Object value, int locId) {
        return logCollectionWriteAccess(map, locId, () -> {
            return map.remove(key, value);
        });
    }

    /**
     * {@link Map#replace(Object, Object)}
     */
    public static Object rvPredictMapReplace(Map map, Object key, Object value, int locId) {
        return logCollectionWriteAccess(map, locId, () -> {
            return map.replace(key, value);
        });
    }

    /**
     * {@link Map#replace(Object, Object, Object)}
     */
    public static boolean rvPredictMapReplace(Map map, Object key, Object oldValue, Object newValue,
            int locId) {
        return logCollectionWriteAccess(map, locId, () -> {
            return map.replace(key, oldValue, newValue);
        });
    }

    /**
     * {@link Map#replaceAll(BiFunction)}
     */
    public static void rvPredictMapReplaceAll(Map map, BiFunction function, int locId) {
        logCollectionWriteAccess(map, locId, () -> {
            map.replaceAll(function);
            return null;
        });
    }

    /**
     * {@link Map#containsKey(Object)}
     */
    public static boolean rvPredictMapContainsKey(Map map, Object key, int locId) {
        return logCollectionReadAccess(map, locId, () -> {
            return map.containsKey(key);
        });
    }

    /**
     * {@link Map#containsValue(Object)}
     */
    public static boolean rvPredictMapContainsValue(Map map, Object value, int locId) {
        return logCollectionReadAccess(map, locId, () -> {
            return map.containsValue(value);
        });
    }

    /**
     * {@link Map#clear()}
     */
    public static void rvPredictMapClear(Map map, int locId) {
        logCollectionWriteAccess(map, locId, () -> {
            map.clear();
            return null;
        });
    }

    /**
     * {@link Map#entrySet()}
     */
    public static Set rvPredictMapEntrySet(Map map, int locId) {
        Set result = map.entrySet();
        viewToBackingCollection.put(result, map);
        return result;
    }

    /**
     * {@link Map#keySet()}
     */
    public static Set rvPredictMapKeySet(Map map, int locId) {
        Set result = map.keySet();
        viewToBackingCollection.put(result, map);
        return result;
    }

    /**
     * {@link Map#values()}
     */
    public static Collection rvPredictMapValues(Map map, int locId) {
        Collection result = map.values();
        viewToBackingCollection.put(result, map);
        return result;
    }

    /**
     * {@link Collections#synchronizedCollection(Collection)}
     */
    public static Collection rvPredictSynchronizedCollection(Collection collection, int locId) {
        Collection syncCollection = Collections.synchronizedCollection(collection);
        viewToBackingCollection.put(syncCollection, collection);
        return syncCollection;
    }

    /**
     * {@link Collections#synchronizedMap(Map)}
     */
    public static Map rvPredictSynchronizedMap(Map map, int locId) {
        Map syncMap = Collections.synchronizedMap(map);
        viewToBackingCollection.put(syncMap, map);
        return syncMap;
    }

    /**
     * {@link Collections#newSetFromMap(Map)}
     */
    public static Set rvPredictNewSetFromMap(Map map, int locId) {
        Set set = Collections.newSetFromMap(map);
        viewToBackingCollection.put(set, map);
        return set;
    }

    /**
     * {@link Stack#push(Object)}
     */
    public static Object rvPredictStackPush(Stack stack, Object e, int locId) {
        return logCollectionWriteAccess(stack, locId, () -> {
            return stack.push(e);
        });
    }

    /**
     * {@link Stack#pop()}
     */
    public static Object rvPredictStackPop(Stack stack, int locId) {
        return logCollectionWriteAccess(stack, locId, () -> {
            return stack.pop();
        });
    }

    /**
     * {@link Stack#peek()}
     */
    public static Object rvPredictStackPeek(Stack stack, int locId) {
        return logCollectionWriteAccess(stack, locId, () -> {
            return stack.peek();
        });
    }

    /**
     * {@link Queue#offer(Object)}
     */
    public static boolean rvPredictQueueOffer(Queue queue, Object e, int locId) {
        return logCollectionWriteAccess(queue, locId, () -> {
            return queue.offer(e);
        });
    }

    /**
     * {@link Queue#remove()}
     */
    public static Object rvPredictQueueRemove(Queue queue, int locId) {
        return logCollectionWriteAccess(queue, locId, () -> {
            return queue.remove();
        });
    }

    /**
     * {@link Queue#poll()}
     */
    public static Object rvPredictQueuePoll(Queue queue, int locId) {
        return logCollectionWriteAccess(queue, locId, () -> {
            return queue.poll();
        });
    }

    /**
     * {@link Queue#element()}
     */
    public static Object rvPredictQueueElement(Queue queue, int locId) {
        return logCollectionReadAccess(queue, locId, () -> {
            return queue.element();
        });
    }

    /**
     * {@link Queue#peek()}
     */
    public static Object rvPredictQueuePeek(Queue queue, int locId) {
        return logCollectionReadAccess(queue, locId, () -> {
            return queue.peek();
        });
    }

    /**
     * {@link Deque#addFirst(Object)}
     */
    public static void rvPredictDequeAddFirst(Deque deque, Object e, int locId) {
        logCollectionWriteAccess(deque, locId, () -> {
            deque.addFirst(e);
            return null;
        });
    }

    /**
     * {@link Deque#addLast(Object)}
     */
    public static void rvPredictDequeAddLast(Deque deque, Object e, int locId) {
        logCollectionWriteAccess(deque, locId, () -> {
            deque.addLast(e);
            return null;
        });
    }

    /**
     * {@link Deque#offerFirst(Object)}
     */
    public static boolean rvPredictDequeOfferFirst(Deque deque, Object e, int locId) {
        return logCollectionWriteAccess(deque, locId, () -> {
            return deque.offerFirst(e);
        });
    }

    /**
     * {@link Deque#offerLast(Object)}
     */
    public static boolean rvPredictDequeOfferLast(Deque deque, Object e, int locId) {
        return logCollectionWriteAccess(deque, locId, () -> {
            return deque.offerLast(e);
        });
    }

    /**
     * {@link Deque#removeFirst()}
     */
    public static Object rvPredictDequeRemoveFirst(Deque deque, int locId) {
        return logCollectionWriteAccess(deque, locId, () -> {
            return deque.removeFirst();
        });
    }

    /**
     * {@link Deque#removeLast()}
     */
    public static Object rvPredictDequeRemoveLast(Deque deque, int locId) {
        return logCollectionWriteAccess(deque, locId, () -> {
            return deque.removeLast();
        });
    }

    /**
     * {@link Deque#getFirst()}
     */
    public static Object rvPredictDequeGetFirst(Deque deque, int locId) {
        return logCollectionReadAccess(deque, locId, () -> {
            return deque.getFirst();
        });
    }

    /**
     * {@link Deque#getLast()}
     */
    public static Object rvPredictDequeGetLast(Deque deque, int locId) {
        return logCollectionReadAccess(deque, locId, () -> {
            return deque.getLast();
        });
    }

    private static int bool2int(boolean b) {
        return b ? 1 : 0;
    }

    private static <T> T logCollectionReadAccess(Object collection, int locId, Supplier<T> closure) {
        return logCollectionAccess(collection, false, locId, closure);
    }

    private static <T> T logCollectionWriteAccess(Object collection, int locId, Supplier<T> closure) {
        return logCollectionAccess(collection, true, locId, closure);
    }

    /**
     * Logs event generated by accessing the (abstract) state of a collection
     * object.
     *
     * @param collection
     *            the collection
     * @param locId
     *            the location identifier
     */
    public static <T> T logCollectionAccess(Object collection, boolean isWrite, int locId,
            Supplier<T> closure) {
        String cname = collection.getClass().getName();
        if (cname.startsWith("com.runtimeverification")) {
            /* skip our own runtime library class which has been manually instrumented */
            return closure.get();
        }

        /* compute wrappers and the real backing collection */
        List wrappers = new ArrayList<>(4);
        Object view = collection;
        Object backingColl;
        while ((backingColl = viewToBackingCollection.get(view)) != null) {
            wrappers.add(view);
            view = backingColl;
        }
        backingColl = view;

        Object mutex = null;
        boolean isThreadSafe = false;
        /* iterate wrappers outside-in looking for synchronization wrapper */
        for (Object wrapper : wrappers) {
            if (wrapper.getClass().getName().startsWith("java.util.Collections$Synchronized")) {
                isThreadSafe = true;
                try {
                    mutex = wrapper instanceof Collection
                            ? SYNC_COLLECTION_GET_MUTEX.invoke(wrapper)
                            : SYNC_MAP_GET_MUTEX.invoke(wrapper);
                } catch (Throwable e) {
                    throw new RuntimeException(e);
                }
                break;
            }
        }

        /* no synchronization wrapper; check the backing collection */
        if (mutex == null) {
            if (backingColl instanceof Vector || backingColl instanceof Hashtable) {
                mutex = backingColl;
                isThreadSafe = true;
            } else if (backingColl instanceof BlockingQueue
                    || backingColl instanceof ConcurrentMap
                    || Pattern.compile("Concurrent|Synchronized|CopyOnWrite|LockFree")
                            .matcher(backingColl.getClass().getName()).find()) {
                mutex = null;
                isThreadSafe = true;
            } else {
                /* unknown collection; assume non-thread-safe */
                mutex = null;
            }
        }

        MutableInt state = collectionToState.computeIfAbsent(backingColl, x -> new MutableInt(0));
        int addrl = System.identityHashCode(backingColl);
        int addrr = -metadata.getVariableId(backingColl.getClass().getName(), MOCK_STATE_FIELD);
        if (mutex != null) {
            synchronized (mutex) {
                int value = state.intValue();
                if (isThreadSafe) {
                    saveLockEvent(EventType.WRITE_LOCK, locId, MONITOR_C, mutex);
                }
                if (isWrite) {
                    state.increment();
                    saveMemAccEvent(EventType.READ, locId, addrl, addrr, value);
                    saveMemAccEvent(EventType.WRITE, locId, addrl, addrr, value + 1);
                } else {
                    saveMemAccEvent(EventType.READ, locId, addrl, addrr, value);
                }
                if (isThreadSafe) {
                    saveLockEvent(EventType.WRITE_UNLOCK, locId, MONITOR_C, mutex);
                }
                return closure.get();
            }
        } else {
            /* `mutex` is null, synchronize on `state` instead: closure.get()
             * may involve locking, so it must be done outside the sync block
             * to avoid deadlock (issue#528) */
            if (isWrite) {
                synchronized (state) {
                    int value = state.intValue();
                    state.increment();
                    if (isThreadSafe) {
                        saveAtomicEvent(EventType.ATOMIC_READ_THEN_WRITE, locId, addrl, addrr,
                                value, value + 1, System.identityHashCode(state));
                    } else {
                        saveMemAccEvent(EventType.READ, locId, addrl, addrr, value);
                        saveMemAccEvent(EventType.WRITE, locId, addrl, addrr, value + 1);
                    }
                }
                return closure.get();
            } else {
                T result = closure.get();
                synchronized (state) {
                    int value = state.intValue();
                    if (isThreadSafe) {
                        saveAtomicEvent(EventType.ATOMIC_READ, locId, addrl, addrr,
                                value, 0, System.identityHashCode(state));
                    } else {
                        saveMemAccEvent(EventType.READ, locId, addrl, addrr, value);
                    }
                }
                return result;
            }
        }
    }

    /**
     * Logs write event generated by accessing some collection (e.g.
     * {@link Collection}, {@link Map}, etc.) using an {@link Iterator}.
     */
    private static <T> T writeUsingIterator(Iterator iterator, int locId, Supplier<T> closure) {
        Object collection = resolveAccessedCollection(iterator);
        if (collection != null) {
            return logCollectionWriteAccess(collection, locId, closure);
        } else {
            return closure.get();
        }
    }

    /**
     * Logs read event generated by accessing some collection (e.g.
     * {@link Collection}, {@link Map}, etc.) using an {@link Iterator}.
     */
    private static <T> T readUsingIterator(Iterator iterator, int locId, Supplier<T> closure) {
        Object collection = resolveAccessedCollection(iterator);
        if (collection != null) {
            return logCollectionReadAccess(collection, locId, closure);
        } else {
            return closure.get();
        }
    }

    private static Set<String> DEBUG_ORPHAN_ITERATORS = Collections.newSetFromMap(new ConcurrentHashMap<>());

    /**
     * Returns the {@link Collection} or {@link Map} that a given
     * {@link Iterator} is accessing or {@code null} if the accessed collection
     * is not available.
     */
    private static Object resolveAccessedCollection(Iterator iterator) {
        Iterable iterable = iteratorToIterable.get(iterator);
        if (iterable == null) {
            /* not all iterators are created by Iterable.iterator() */
            if (DEBUG_ORPHAN_ITERATORS.add(iterator.getClass().getName())) {
                config.logger().debug("Unable to find the collection accessed by " + iterator);
            }
            return null;
        } else {
            Object view = iterable;
            Object backingColl;
            while ((backingColl = viewToBackingCollection.get(view)) != null) {
                view = backingColl;
            }
            return view;
        }
    }

    public static void saveMemAccEvent(EventType eventType, int locId, int addrl, int addrr,
            long value) {
        logger.log(eventType, locId, addrl, addrr, value, 0);
    }

    public static void saveThreadSyncEvent(EventType eventType, int locId, long tid) {
        logger.log(eventType, locId, (int) (tid >> 32), (int) tid, 0, 0);
    }

    public static void saveLockEvent(EventType eventType, int locId, byte LOCK_TYPE, Object lock) {
        if (lock == null) {
            throw new NullPointerException();
        }
        logger.log(eventType, locId, LOCK_TYPE, System.identityHashCode(lock), 0, 0);
    }

    private static void saveMetaEvent(EventType eventType, int locId) {
        logger.log(eventType, locId, 0, 0, 0, 0);
    }

    public static void saveAtomicEvent(EventType eventType, int locId, int addrl, int addrr,
            long value1, long value2) {
        logger.log(eventType, locId, addrl, addrr, value1, value2);
    }

    /**
     * Similar to
     * {@link RVPredictRuntime#saveAtomicEvent(EventType, int, int, int, long, long)}
     * , but allows the caller to provide an atomic lock ID that is different
     * from {@code addrl}.
     */
    public static void saveAtomicEvent(EventType eventType, int locId, int addrl, int addrr,
            long value1, long value2, int atomLock) {
        logger.log(eventType, locId, addrl, addrr, value1, value2, atomLock);
    }

}
